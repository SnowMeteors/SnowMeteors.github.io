---
title: 数据结构之链表篇
abbrlink: 34786
date: 2020-07-17 15:15:24
tags:
  - 链表
categories:
  - 数据结构
---
### 前言
　　此篇记录一下本人对链表的理解，重点讲解链表的插入与删除算法，相信大家在学习数据结构的时候，第一篇就是链表。简直是给了我一个下马威。我对应它放弃了多次，早在1年前我就接触了链表，emmm，放弃。始终不甘心，然后等到高考暑假后再次鼓起勇气认识它，好吧，又被它打跑了。终于在前几天重新再来学习链表，功夫不负有心人，彻彻底底的搞懂了链表。
　　<!-- more -->

### 基本概念
　　链表由n个结点链组成，第一个结点的存储位置叫做头指针，最后一个结点的指针为“空”(NULL)
　　结点：包括数据域和指针域
　　头指针：指向链表中第一个结点的地址
　　头结点：在单链表的第一个结点前附设的一个结点
　　头指针是链表的必要元素，头结点是为了操作的统一和方便而设定的，其数据域一般无意义(可用来保存链表的长度)，头结点可有可无。
　　

### 单链表
#### 结构图
　　<img src="https://s1.ax1x.com/2020/07/16/UDUnHO.png">
　　再次强调，请理解头结点和头指针，头指针不是链表的第一个结点，而是指向链表的第一个结点的地址！！

　　首先定义链表的结点
```c
// 定义链表的结点
typedef struct node{
    int id;				//数据域，这里为了方便示例全部采用id值
    struct node * next;	//指针域，指向下一个结点的地址
}Node;
```
　　然后定义链表的头结点与头指针

```c
// 头结点
// 在定义链表时，习惯性的会定义头结点，以便统一链表结点的插入和删除操作
typedef struct LinkList{
    Node * next;    //头指针（如果链表有头结点，next就指向头结点，没有就指向第一个结点）
    int length;
}LinkList;
```
　　上面这段代码，你可能会好奇怎么使用，或者说为什么要这样定义，而不是只要有链表的结点不就完了吗，还要这段代码干嘛，别急后面会用到。
#### 单链表插入
　　插入分为两种情况，第一种插入到第一个位置，第二种插入到其他位置。
　　<b>第一种情况</b>：插入第一个位置
　<img src="https://s1.ax1x.com/2020/07/17/Uy5EPe.gif">
　　从图片不难看出，首先将要插入的a结点的next指向头指针，即第一个结点(a<sub>1</sub>)的地址，然后将链表的头指针指向新插入的a结点的地址，就完成了

　　<b>第二种情况</b>：插入到其他位置
　　这里假设插入到3位置
　　<img src="https://s1.ax1x.com/2020/07/16/UD27fx.gif">
　　让a结点的next指向a<sub>2</sub>的next，然后a<sub>2</sub>的next指向a，就完成了插入。所以，首先要找到要插入的位置的上一个结点

```c
// 在指定的位置pos插入元素id
void InsertLinkList(LinkList *linkList, int pos, int id)
{
    // 1.创建空结点并为数据域赋值
    Node *node = (Node *)malloc(sizeof(Node)); //创建结点
    node->id = id;
    node->next = NULL;

    // 2.找到要插入位置的结点
    // 如果插入的是第一个元素
    if (pos == 1)
    {
        node->next = linkList->next;
        linkList->next = node; //重新设置头指针
    }
    else
    {
        // 通过循环找到要插入的结点位置
        Node *prev = linkList->next; // 获取到插入pos前一个结点的地址
        for (int i = 1; i < pos - 1 && prev != NULL; i++)
        {
            prev = prev->next;
        }

        // 3.将结点插入并对接前面的结点
        if (prev != NULL)
        {
            //必须先让插入的结点的next获取到前一个结点的next指向的地址空间，
            //低下这两行代码不能调换顺序
            node->next = prev->next;
            prev->next = node;
        }
        // 并不需要单独考虑结点在最后添加的情况
        // 如果在尾部添加结点。因为在前面，就设置了node->next = NULL
        // 所以链表的尾结点插入好后下一个空间的地址就是空
    }

    linkList->length++;
}
```
#### 单链表初始化
　　定义初始化函数，此初始化只出现本篇一次，后面的双链表和循环链表将不会出现初始化示例

```c
// 初始化链表
void InitLinkList(LinkList * linkList,int length)
{
    linkList.length = 0;   //初始化链表长度
    //注意头指针的定义是，即使链表为空，头指针也不为空，这里是本人的代码习惯，所以将头指针设置为空
    linkList.next = NULL;  //初始头指针为空
    for (int i = 0; i < length; i++)
    {
        InsertLinkList(linkList,i + 1,i + 1);
    }
}
```
#### 单链表删除
　　这里也要分两种情况，第一种情况:删除的位置在第一个，第二种情况:在其他位置删除
　　<b>第一种情况</b>:删除的位置在第一个示例
　　<img src="https://s1.ax1x.com/2020/07/16/UD5K6P.gif">
　　整个的逻辑其实是，直接让头指针指向a<sub>2</sub>即可，然后释放掉a<sub>1</sub>的内存空间即可
　　
　　<b>第二种情况</b>:在其他位置删除
　　假设删除的位置是2，那么需要找到上一个结点，从图片可知让a<sub>1</sub>的next指向a<sub>2</sub>的next，然后释放掉a<sub>2</sub>的空间即可
　　<img src="https://s1.ax1x.com/2020/07/17/Uy4UAO.gif">

```c
// 在指定位置删除结点
void DeleteLinkList(LinkList *linkList, int pos)
{
    // 1.指向链表的第一个结点
    Node *node = linkList->next;

    // 2.删除的结点为第一个
    if (pos == 1)
    {
        linkList->next = node->next; //重新设置头指针
        free(node);					 //记得要使用free()，这一步容易忽略
        linkList->length--;
        return;
    }

    // 3.获取要删除的结点的前一个结点地址
    for (int i = 1; i < pos - 1; i++)
    {
        node = node->next;
    }
    Node *delNode = node->next; //要删除的结点的地址
    node->next = delNode->next; //重新指向地址
    free(delNode);
    linkList->length--;
}
```
#### 清空链表
　　通过循环链表的方式，去清空链表，代码胜千言
　　<img src="https://s1.ax1x.com/2020/07/17/UyLrvD.gif">

```c
// 清空链表
void ClearLinkList(LinkList *linkList)
{
    Node *node = linkList->next;	//指向链表的第一个结点
    Node *nextNode;
    while (node != NULL)
    {
        nextNode = node->next; //先记录当前结点的下一个结点以便释放当前结点的内容
        free(node);
        node = nextNode;		//重新获取结点
    }
    linkList->next = NULL;
    linkList->length = 0;
}
```
　main函数展示，本篇也只出现这一次，其他类型的链表main内容都大同小异

```c
int main()
{
    LinkList linkList;

    InitLinkList(&linkList, 4);
    PrintLinkList(&linkList);
    InsertLinkList(&linkList,1,2);
    DeleteLinkList(&linkList,1);
    ClearLinkList(&linkList);
    PrintLinkList(&linkList);
}
```
　　理解了单链表后，那么后面的循环链表和双向链表都大同小异。而从上面的代码中可看出头指针是非常重要的，用起来非常方便。
### 循环链表
#### 结构图
　　<img src="https://s1.ax1x.com/2020/07/17/UystJ0.png">
　　循环链表最大的特点是尾结点的指针域指向第一个结点
　　定义循环链表的结点

```c
// 循环链表的结点
typedef struct CircularNode
{
    int id;                    //数据域
    struct CircularNode *next; //指向下个结点的指针域
} CircularNode;
```
　　定义循环链表的头结点

```c
// 头结点
typedef struct CircularLinkList
{
    CircularNode *next; //指向第一个结点的指针，头指针
    int length;
} CircularLinkList;
```
#### 循环链表的插入
　　循环链表的插入稍微复杂了一点点，有4种情况
　　<b>第一种:</b>插入位置在第一个，链表长度不为0
　　<b>第二种:</b>插入位置在第一个，链表长度为0
　　<b>第三种:</b>插入位置在尾部
　　<b>第四种:</b>插入位置在非上述情况
　　虽然看起来要四种情况，但其实总的来说只有两大种，其他两小种只需要在里面，加一个if判断就能搞定

　　<b>第一种</b>:插入位置在第一个，链表长度不为0
　　<img src="https://s1.ax1x.com/2020/07/17/Uyfzi4.gif">

　　先让a结点的next指向第一个结点的地址，然后让尾结点的next指向a结点的地址，最后头指针指向a结点的地址即可

　　<b>第二种:</b>插入位置在第一个，链表长度为0